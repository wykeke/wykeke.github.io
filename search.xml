<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/2022/03/13/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DBS</title>
    <url>/2020/07/28/DBS/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a><strong>绪论</strong></h1><h1 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a><strong>数据库系统概述</strong></h1><p><em>数据库的4个基本概念</em><br>数据、数据库、数据库管理系统是与数据库技术密切相关的四个基本概念。<br>1、数据<br>定义：描述事物的符号记录称为数据。<br>数据的含义称为数据的语义，数据与其语义是不可分的。<br>记录是计算机中表示和存储数据的一种格式或一种方法。</p>
<p>2、数据库<br>数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。<br>数据库中的数据按一定的数据模型组织、描述和存储、具有较小的冗余度、较高的数据独立性和易扩展性，<br>并可为各种用户共享。概括的讲，数据库数据具有永久存储、有组织和可共享三个基本特点。</p>
<p>3、数据库管理系统<br>数据库管理系统是位于用户与操作系统之间的一层管理软件。<br>数据库管理系统和操作软件一样，是计算机的基础软件，也是一个大型复杂的软件系统。<br>主要功能：<br>（1）、数据定义功能<br>数据库管理系统提供数据定义语言DDL。用户通过它可以方便地对数据库中的数据对象的组成与结构进行定义。</p>
<p>（2）、数据组织、存储和管理<br>数据库管理系统要分类组织，存储和管理各种数据，包括数据字典，用户数据。设计的存取路径等。<br>要确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。<br>数据组织和存储的基本目标是提高存储空间利用率和方便存取，提取多种存取方法，<br>（如索引查找、hash查找、顺序查找）来提高存储效率。</p>
<p>（3）、数据操纵功能<br>数据操纵语言DML:用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</p>
<p>（4）、数据库的事务管理和运行管理<br>数据库在建立、运用和维护时由数还力系统统一管理和控制，以保证事务的正确运行，<br>保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。</p>
<a id="more"></a>


<hr>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a><strong>数据结构和算法</strong></h2><hr>
<h2 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a><strong>稀疏数组和队列</strong></h2><p><em>稀疏数组</em><br>稀疏数组：第一行存放原始数组的行数、列数、有效数据个数<br>          第二行开始存放有效数据，例如第一个有效数据的行、列、元素值<br>二维数据转稀疏数组的思路<br>1、遍历原始的二维数组，得到有效数据的个数sum<br>2、根据sum创建sparseArr int[sum+1][3]  //sum+1是因为多了第一行存放原始数组的行数、列数、有效数据个数<br>3、将二维数组的有效数据存入到稀疏数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个二维数组11*11</span><br><span class="line">		&#x2F;&#x2F;0表示没有棋子，1表示黑子，2表示蓝子</span><br><span class="line">		int chessArr1[][] &#x3D; new int[11][11];</span><br><span class="line">		chessArr1[1][2] &#x3D; 1;</span><br><span class="line">		chessArr1[2][3] &#x3D; 2;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;转成稀疏数组</span><br><span class="line">		&#x2F;&#x2F;遍历数组找出有效数据sum</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; chessArr1.length; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; chessArr1[0].length; j++) &#123;</span><br><span class="line">				if (chessArr1[i][j] !&#x3D; 0) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;定义稀疏数组</span><br><span class="line">		int sparseArr[][] &#x3D; new int[sum + 1][3];</span><br><span class="line">		sparseArr[0][0] &#x3D; chessArr1.length;</span><br><span class="line">		sparseArr[0][1] &#x3D; chessArr1[0].length;</span><br><span class="line">		sparseArr[0][2] &#x3D; sum;</span><br><span class="line">		int k &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;遍历原始二维数组存放到稀疏数组</span><br><span class="line">		for (int i &#x3D; 0; i &lt; chessArr1.length; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; chessArr1[0].length; j++) &#123;</span><br><span class="line">				if(chessArr1[i][j] !&#x3D; 0) &#123;</span><br><span class="line">					k++;</span><br><span class="line">					sparseArr[k][0] &#x3D; i;</span><br><span class="line">					sparseArr[k][1] &#x3D; j;</span><br><span class="line">					sparseArr[k][2] &#x3D; chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;输出稀疏数组&quot;);</span><br><span class="line">		&#x2F;&#x2F;输出稀疏数组</span><br><span class="line">		for (int i &#x3D; 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			System.out.printf(&quot;%d\t%d\t%d\t\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;稀疏数组转二维数组</span><br><span class="line">		int chessArr2[][] &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">		for (int i &#x3D; 1; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			chessArr2[sparseArr[i][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;输出二维数组&quot;);</span><br><span class="line">		&#x2F;&#x2F;输出二维数组</span><br><span class="line">		for (int i &#x3D; 0; i &lt; chessArr2.length; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; chessArr2[0].length; j++) &#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;,chessArr2[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>队列</em><br>队列：先进先出<br>使用数组模拟环形队列：<br>1、front指向队列的第一个元素，rear指向队列的最后一个元素的后一个位置，初始值都为0<br>2、队满条件：(rear + 1) % maxSize == front<br>3、队空条件，rear == front<br>4、队列中有效的数据的个数：(rear + maxSize - front) % maxSize</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个队列</span><br><span class="line">		ArrayQueue arrayQueue &#x3D; new ArrayQueue(3);&#x2F;&#x2F;设置的3最大有效数据为2，因为空出一个位置给rear</span><br><span class="line">		char key &#x3D; &#39; &#39;;&#x2F;&#x2F;接受用户输入</span><br><span class="line">		Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		System.out.println(&quot;s(show)：显示队列&quot;);</span><br><span class="line">		System.out.println(&quot;a(add)：添加数据&quot;);</span><br><span class="line">		System.out.println(&quot;g(get)：从队列取出数据&quot;);</span><br><span class="line">		System.out.println(&quot;e(exit)：退出程序&quot;);</span><br><span class="line">		</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.print(&quot;请输入一个字符：&quot;);</span><br><span class="line">			key &#x3D; scanner.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">			case &#39;s&#39;: &#123;</span><br><span class="line">				arrayQueue.showQueue();</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			case &#39;a&#39;:&#123;</span><br><span class="line">				System.out.print(&quot;添加一个数据：&quot;);</span><br><span class="line">				arrayQueue.addQueue(scanner.nextInt());</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			case &#39;g&#39;:&#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.printf(&quot;取出的数据是：%d\n&quot;,arrayQueue.getQueue());</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			case &#39;e&#39;:&#123;</span><br><span class="line">				scanner.close();</span><br><span class="line">				loop &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			default:</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用数组模拟队列</span><br><span class="line">&#x2F;&#x2F;队列先进先出</span><br><span class="line">class ArrayQueue&#123;</span><br><span class="line">	private int maxSize; &#x2F;&#x2F;数组最大容量</span><br><span class="line">	&#x2F;&#x2F;front指向队列的第一个元素</span><br><span class="line">	private int front; &#x2F;&#x2F;队列头</span><br><span class="line">	&#x2F;&#x2F;rear指向队列的最后一个元素的后一个位置</span><br><span class="line">	private int rear; &#x2F;&#x2F;队列尾</span><br><span class="line">	private int arr[]; &#x2F;&#x2F;存放数据，模拟队列</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建队列的构造器</span><br><span class="line">	public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">		maxSize &#x3D; arrMaxSize;</span><br><span class="line">		arr &#x3D; new int[maxSize];</span><br><span class="line">		&#x2F;&#x2F;可以不写，因为默认为0</span><br><span class="line">		&#x2F;&#x2F;front &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;rear &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;判断队列是否满</span><br><span class="line">	public boolean isFull() &#123;</span><br><span class="line">		return (rear + 1) % maxSize &#x3D;&#x3D; front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">	public boolean isEmpty() &#123;</span><br><span class="line">		return rear &#x3D;&#x3D; front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;添加数据到队列</span><br><span class="line">	public void addQueue(int n) &#123;</span><br><span class="line">		&#x2F;&#x2F;判断队列是否满</span><br><span class="line">		if(isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列满，不能加入&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;直接将数据加入，因为rear已经指向元素的后一个位置</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">		&#x2F;&#x2F;将rear后移，考虑取模</span><br><span class="line">		rear &#x3D; (rear + 1) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;获取队列数据，出队列</span><br><span class="line">	public int getQueue() &#123;</span><br><span class="line">		&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">		if(isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F;队列为空抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;分析出front是指向队列的第一个元素</span><br><span class="line">		&#x2F;&#x2F;1、先把front对应的值保留到一个临时变量</span><br><span class="line">		&#x2F;&#x2F;2、将front后移，考虑取模</span><br><span class="line">		&#x2F;&#x2F;3、将临时保存的变量返回</span><br><span class="line">		int value &#x3D; arr[front];</span><br><span class="line">		front &#x3D; (front + 1) % maxSize;</span><br><span class="line">		return value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示队列的所有数据</span><br><span class="line">	public void showQueue() &#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列为空，没有数据&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;从front开始遍历，找到需要遍历的元素个数</span><br><span class="line">		for (int i &#x3D; front; i &lt; front + size(); i++) &#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d] &#x3D; %d\n&quot;,i % maxSize,arr[i % maxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;求出当前队列有效数据的个数</span><br><span class="line">	private int size() &#123;</span><br><span class="line">		return (rear + maxSize - front) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h2><p>1、链表以节点的方式来存储<br>2、每个节点包括data域，next域：指向下一个节点<br>3、不一定连续存储<br>4、链表分为带头节点的链表和没有头节点的链表，分情况而定</p>
<p>虚拟头节点：</p>
<blockquote>
<p>ListNode dummyHead  = new ListNode();<br> dummyHead.next = head;</p>
</blockquote>
<p><em>单链表</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;得到链表头节点</span><br><span class="line">		Node head &#x3D; createList();</span><br><span class="line">		&#x2F;&#x2F;显示单链表</span><br><span class="line">		showList(head.next);;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;有效节点个数</span><br><span class="line">		System.out.println(&quot;有效节点数：&quot;+getLength(head));</span><br><span class="line">	</span><br><span class="line">		&#x2F;&#x2F;倒数第k个节点</span><br><span class="line">		System.out.println(&quot;倒数第3个节点：&quot;+findLastIndexNode(head, 3));</span><br><span class="line">	</span><br><span class="line">		&#x2F;&#x2F;逆序打印链表(没有改变链表结构</span><br><span class="line">		System.out.printf(&quot;逆序打印链表：&quot;);</span><br><span class="line">		reversePrint(head);</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;反转链表(改变了链表结构</span><br><span class="line">		System.out.printf(&quot;反转后的链表为：&quot;);</span><br><span class="line">		showList(reverseList(head));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;查找单链表中的倒数第k个节点</span><br><span class="line">	public static Node findLastIndexNode(Node head,int k) &#123;</span><br><span class="line">		&#x2F;&#x2F;快慢指针，将快指针遍历k个节点，再让快慢指针一起遍历</span><br><span class="line">		&#x2F;&#x2F;当快指针走到末尾的时候慢指针刚好到倒数第k个节点</span><br><span class="line">		Node fast &#x3D; head;</span><br><span class="line">		Node slow &#x3D; head;</span><br><span class="line">		for(int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			fast &#x3D; fast.next;</span><br><span class="line">			if (fast &#x3D;&#x3D; null) &#123;</span><br><span class="line">				System.out.println(&quot;数据超范围，请输入有效数据&quot;);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while (fast.next !&#x3D; null) &#123;</span><br><span class="line">			slow &#x3D; slow.next;</span><br><span class="line">			fast &#x3D; fast.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return slow.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;反转链表</span><br><span class="line">	public static Node reverseList(Node head) &#123;</span><br><span class="line">		&#x2F;&#x2F;https:&#x2F;&#x2F;programmercarl.com&#x2F;0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</span><br><span class="line">		&#x2F;&#x2F;调换链表的指向</span><br><span class="line">		&#x2F;&#x2F;定义一个cur指向头结点，再定义一个pre为null，让cur.next指向pre</span><br><span class="line">		Node cur &#x3D; head.next;</span><br><span class="line">		Node pre &#x3D; null;</span><br><span class="line">		Node temp &#x3D; null;&#x2F;&#x2F;保存</span><br><span class="line">		while (cur !&#x3D; null) &#123;</span><br><span class="line">			temp &#x3D; cur.next;</span><br><span class="line">			cur.next &#x3D; pre;</span><br><span class="line">			pre &#x3D; cur;</span><br><span class="line">			cur &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">		return pre;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;逆序打印链表</span><br><span class="line">	&#x2F;&#x2F;方式1：先反转链表再遍历 （会破坏原来的单链表结构，不建议</span><br><span class="line">	&#x2F;&#x2F;方式2，采用栈结构，将各个节点压入栈中，利用栈的先进后出特点实现逆序打印</span><br><span class="line">	public static void reversePrint(Node head) &#123;</span><br><span class="line">		if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">			System.out.println(&quot;链表为空，不能打印&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();</span><br><span class="line">		Node cur &#x3D; head.next;</span><br><span class="line">		while (cur !&#x3D; null) &#123;</span><br><span class="line">			stack.push(cur);  &#x2F;&#x2F;将节点压入栈中</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		while (stack.size() &gt; 0) &#123;</span><br><span class="line">			System.out.printf(&quot;%d &quot;,stack.pop().value); &#x2F;&#x2F;pop出栈，先进后出</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;得到链表中的有效节点个数</span><br><span class="line">	&#x2F;&#x2F;因为此例中头节点不存储任何数据，所以不统计在内</span><br><span class="line">	public static int getLength(Node head) &#123;</span><br><span class="line">		if(head.next &#x3D;&#x3D; null) return 0;</span><br><span class="line">		int length &#x3D; 0;</span><br><span class="line">		Node cur &#x3D; head.next;</span><br><span class="line">		while (cur !&#x3D; null) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建链表</span><br><span class="line">	public static Node createList() &#123;</span><br><span class="line">		&#x2F;&#x2F;创建链表</span><br><span class="line">		SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">			Node node &#x3D; new Node(i+1);</span><br><span class="line">			singleLinkedList.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">		return singleLinkedList.getHead();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表</span><br><span class="line">	public static void showList(Node head) &#123;</span><br><span class="line">		if(head &#x3D;&#x3D; null) &#123;</span><br><span class="line">			System.out.println(&quot;链表为空&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		Node temp &#x3D; head;</span><br><span class="line">		while (temp !&#x3D; null) &#123;</span><br><span class="line">			System.out.printf(&quot;%d &quot;, temp.value);</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义链表管理节点</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点，头节点不要动</span><br><span class="line">	private Node head &#x3D; new Node(0);</span><br><span class="line">	</span><br><span class="line">	public Node getHead() &#123;</span><br><span class="line">		&#x2F;&#x2F;这里得到的头节点是无效节点，不存储任何数据，它的下一个节点才是有效头节点</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setHead(Node head) &#123;</span><br><span class="line">		this.head &#x3D; head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;添加节点到单链表</span><br><span class="line">	public void add(Node node) &#123;</span><br><span class="line">		Node temp &#x3D; head;</span><br><span class="line">		while (temp.next !&#x3D; null) &#123;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.next &#x3D; node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义链表节点</span><br><span class="line">class Node&#123;</span><br><span class="line">	public int value;</span><br><span class="line">	public Node next;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public Node(int val) &#123;</span><br><span class="line">		this.value &#x3D; val;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;为了显示方便，重写toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Node [value&#x3D;&quot; + value + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>双向链表</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DoubleNode head &#x3D; createList();</span><br><span class="line">		&#x2F;&#x2F;显示链表</span><br><span class="line">		showList(head.next);</span><br><span class="line">		System.out.println(head.next.next.next.pre);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建链表</span><br><span class="line">	public static DoubleNode createList() &#123;</span><br><span class="line">		&#x2F;&#x2F;创建链表</span><br><span class="line">		DoubleLinkedList doubleLinkedList &#x3D; new DoubleLinkedList();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">			DoubleNode node &#x3D; new DoubleNode(i+1);</span><br><span class="line">			doubleLinkedList.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">		return doubleLinkedList.getHead();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表</span><br><span class="line">	public static void showList(DoubleNode head) &#123;</span><br><span class="line">		if(head &#x3D;&#x3D; null) &#123;</span><br><span class="line">			System.out.println(&quot;链表为空&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		DoubleNode temp &#x3D; head;</span><br><span class="line">		while (temp !&#x3D; null) &#123;</span><br><span class="line">			System.out.printf(&quot;%d &quot;, temp.value);</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义链表管理节点</span><br><span class="line">class DoubleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点，头节点不要动</span><br><span class="line">	private DoubleNode head &#x3D; new DoubleNode(0);</span><br><span class="line">	</span><br><span class="line">	public DoubleNode getHead() &#123;</span><br><span class="line">		&#x2F;&#x2F;这里得到的头节点是无效节点，不存储任何数据，它的下一个节点才是有效头节点</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setHead(DoubleNode head) &#123;</span><br><span class="line">		this.head &#x3D; head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;添加节点到双向链表</span><br><span class="line">	public void add(DoubleNode node) &#123;</span><br><span class="line">		DoubleNode temp &#x3D; head;</span><br><span class="line">		while (temp.next !&#x3D; null) &#123;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.next &#x3D; node;</span><br><span class="line">		node.pre &#x3D; temp; &#x2F;&#x2F;将前指针与temp连接起来</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个双向链表的节点，有前指针和后指针</span><br><span class="line">class DoubleNode&#123;</span><br><span class="line">	public int value;</span><br><span class="line">	public DoubleNode next;</span><br><span class="line">	public DoubleNode pre;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public DoubleNode(int val) &#123;</span><br><span class="line">		this.value &#x3D; val;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;为了显示方便，重写toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Double [value&#x3D;&quot; + value + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
  </entry>
  <entry>
    <title>java</title>
    <url>/2020/01/13/java/</url>
    <content><![CDATA[<h1 id="开始我的java学习之旅啦"><a href="#开始我的java学习之旅啦" class="headerlink" title="开始我的java学习之旅啦"></a>开始我的java学习之旅啦</h1><p><strong>Hello World!</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hello&#123;				&#x2F;&#x2F;新建类</span><br><span class="line">	public static void main(String[] args)&#123;		&#x2F;&#x2F;主方法</span><br><span class="line">	System.out.println(Hello World!);		&#x2F;&#x2F;输出</span><br><span class="line">	&#x2F;&#x2F;println输出结果后自动换行，print输出结果后不换行</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java程序中的main()方法必须声明为<code>public static void</code><br>String[] args是一个字符串类型的数组，它是main()方法的参数</p>
<a id="more"></a>

<p><strong>计算1+1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">			int a,b;</span><br><span class="line">			a&#x3D;in.nextInt();</span><br><span class="line">			b&#x3D;in.nextInt();</span><br><span class="line">			System.out.println(a+b); &#x2F;&#x2F;运行结果 2</span><br><span class="line">			System.out.println(&quot;a+b&#x3D;&quot; + (a+b)); &#x2F;&#x2F;运行结果 a+b&#x3D;2</span><br><span class="line">			System.out.println(a + &quot;+&quot; + b + &quot;&#x3D;&quot; + (a+b) ); &#x2F;&#x2F;运行结果 1+1&#x3D;2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scanner类可以获取用户输入，这里用nextInt()的方法接收<br><a href="https://blog.csdn.net/u013568373/article/details/92803182" target="_blank" rel="noopener"><strong>Scanner类用法总结</strong></a></p>
<p>Java的基本数据类型与c语言差不多，但Java中多了一种布尔类型，通过关键字boolean来定义布尔类型变量，只有true和false两个值</p>
<p><strong>标识符</strong> 可由字母、数字、下划线(_)、美元符号($)组成，第一个字符不能是数字。<br><strong>声明常量</strong>  final 数据类型 常量名称[=值]</p>
<blockquote>
<p>final double PI = 3.14</p>
</blockquote>
<p><strong>循环控制</strong><br>Java提供了标签功能，可以让break跳出指定循环体，continue也支持标签功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i,j;</span><br><span class="line">		Loop: for(i&#x3D;0;i&lt;3;i++) &#123;  &#x2F;&#x2F;在for循环前用标签标记</span><br><span class="line">			for(j&#x3D;0;j&lt;3;j++) &#123;</span><br><span class="line">				if(j&#x3D;&#x3D;2) &#123;</span><br><span class="line">					break Loop;	&#x2F;&#x2F;跳出Loop标签标记的循环</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(&quot;i&#x3D;&quot;+i+&quot; j&#x3D;&quot;+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>i=0&emsp;j=0<br>i=0&emsp;j=1</p>
</blockquote>
<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><p>1、String(char a[])    //用一个字符数组a创建String对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char a[]&#x3D;&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;</span><br><span class="line">String s&#x3D;new String(a);</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">String s&#x3D;new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>2、String(char a[],int offset,int length)  //offset表示开始截取位置，length表示截取长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char a[]&#x3D;&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;</span><br><span class="line">String s&#x3D;new String(a,2,3);</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">String s&#x3D;new String(&quot;llo&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer类</strong><br>StringBuffer类表示内容与长度动态可变的字符串缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将String转为StringBuffer并实现替换字符和查找字符功能</span><br><span class="line">String s &#x3D; &quot;abcd&quot;;</span><br><span class="line">StringBuffer s1 &#x3D; new StringBuffer(s);</span><br><span class="line">s1.replace(0, 1, &quot;0&quot;); &#x2F;&#x2F;s1 &#x3D; 0bcd</span><br><span class="line">int i &#x3D; s1.substring(0,4).indexOf(&#39;b&#39;); &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p><strong>字符串连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s1&#x3D;&quot;Hello&quot;;</span><br><span class="line">		String s2&#x3D;&quot;World&quot;;</span><br><span class="line">		String s&#x3D;s1+&quot; &quot;+s2;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>Hello World</p>
</blockquote>
<p><strong>获取字符串长度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;Hello World&quot;;</span><br><span class="line">		int size&#x3D;s.length();</span><br><span class="line">		System.out.println(size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>11</p>
</blockquote>
<p>length()方法返回的长度包括字符串中的空格</p>
<p><strong>字符串查找</strong><br>1、查找某字符或字符串的位置<br>indexOf() //该方法用于返回指定字符或字符串在字符数组中首次出现的索引位置，若未检索到搜索内容，返回-1<br>lastIndexOf() //检索最后一次出现的索引位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;Hello World&quot;;</span><br><span class="line">		int l1&#x3D;s.indexOf(&quot;l&quot;);</span><br><span class="line">		int l2&#x3D;s.lastIndexOf(&quot;l&quot;);</span><br><span class="line">		System.out.println(&quot;l首次出现的位置是：&quot;+l1);</span><br><span class="line">		System.out.println(&quot;l最后一次出现的位置是：&quot;+l2);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>l首次出现的位置是：2<br>l最后一次出现的位置是：9</p>
</blockquote>
<p>2、查找某位置的字符<br>charAt()  //该方法可将指定索引处的字符返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;Hello World&quot;;</span><br><span class="line">		char mychar&#x3D;s.charAt(2);</span><br><span class="line">		System.out.println(&quot;索引位置2处的字符是：&quot;+mychar);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>索引位置2处的字符是：l</p>
</blockquote>
<p><strong>获取子字符串</strong><br>substring()  //利用字符串下标进行截取，字符串下标从0开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;Hello World&quot;;</span><br><span class="line">		String s1&#x3D;s.substring(0,4);  &#x2F;&#x2F;从0位置到4位置结束</span><br><span class="line">		String s2&#x3D;s.substring(6);  &#x2F;&#x2F;从6位置到结尾</span><br><span class="line">		System.out.println(s1+&quot;\n&quot;+s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>Hell<br>World</p>
</blockquote>
<p><strong>去除空格</strong><br>trim()  //忽略前导空格和尾部空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;  Hello World &quot;;</span><br><span class="line">		System.out.println(&quot;字符串原来的长度：&quot;+s.length());</span><br><span class="line">		System.out.println(&quot;去除首尾空格后的长度：&quot;+s.trim().length());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>字符串原来的长度：14<br>去除首尾空格后的长度：11</p>
</blockquote>
<p><strong>字符串替换</strong><br>replace()  //若待替换内容重复多次，将全部替换成新的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;Hello World&quot;;</span><br><span class="line">		String s1&#x3D;s.replace(&quot;H&quot;,&quot;h&quot;);</span><br><span class="line">		System.out.println(s1);																															</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断字符串的开始和结尾</strong><br>startsWith(),endsWith()     //返回值为boolean类型，只有true和false两个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;Hello World&quot;;</span><br><span class="line">		boolean b&#x3D;s.startsWith(&quot;H&quot;);</span><br><span class="line">		&#x2F;&#x2F;判断字符串是否以&quot;H&quot;开头，运行结果为true</span><br><span class="line">		boolean b1&#x3D;s.endsWith(&quot;D&quot;);</span><br><span class="line">		&#x2F;&#x2F;判断字符串是否以&quot;D&quot;结尾，运行结果为false</span><br><span class="line">		System.out.println(b);																															</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把字符串str附加在当前字符串末尾</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s1 &#x3D; &quot;Hello&quot;;</span><br><span class="line">		String s2 &#x3D; s1.concat(&quot;World&quot;);</span><br><span class="line">		System.out.println(&quot;s1的值为：&quot;+s1);</span><br><span class="line">		System.out.println(&quot;s2的值为：&quot;+s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>s1的值为：Hello<br>s2的值为：HelloWorld</p>
</blockquote>
<p><strong>判断字符串是否相等</strong><br>1、equals() //返回值为boolean类型，区分大小写<br>2、equalsIgnoreCase()  //返回值为boolean类型，不区分大小写<br>“==”:比较地址，equals()：仅比较内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s1&#x3D;&quot;abc&quot;;</span><br><span class="line">		String s2&#x3D;&quot;ABC&quot;;</span><br><span class="line">		boolean b1&#x3D;s1.equals(s2);</span><br><span class="line">		boolean b2&#x3D;s1.equalsIgnoreCase(s2);</span><br><span class="line">		System.out.println(&quot;b1的值为：&quot;+b1);</span><br><span class="line">		System.out.println(&quot;b2的值为：&quot;+b2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>b1的值为：false<br>b2的值为：true</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 &#x3D; &quot;Hello&quot;;</span><br><span class="line">String s2 &#x3D; &quot;Hello&quot;;</span><br><span class="line">String s3 &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">String s4 &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;T</span><br><span class="line">System.out.println(s1.equals(s2));&#x2F;&#x2F;T</span><br><span class="line">System.out.println(s1&#x3D;&#x3D;s3);&#x2F;&#x2F;F</span><br><span class="line">System.out.println(s1.equals(s3));&#x2F;&#x2F;T</span><br><span class="line">System.out.println(s3&#x3D;&#x3D;s4);&#x2F;&#x2F;F</span><br><span class="line">System.out.println(s3.equals(s4));&#x2F;&#x2F;T</span><br></pre></td></tr></table></figure>


<p><strong>按字典顺序比较两个字符串</strong><br>compareTo()  //比较基于字符串各个字符的Unicode值，返回Unicode值之差，若两字符串相等，结果为0；排在后面的值更大，小写字母在大写字母之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s1&#x3D;&quot;aba&quot;;</span><br><span class="line">		String s2&#x3D;&quot;abc&quot;;</span><br><span class="line">		int b1&#x3D;s1.compareTo(s2);</span><br><span class="line">		int b2&#x3D;s2.compareTo(s1);</span><br><span class="line">		System.out.println(&quot;b1的值为：&quot;+b1);</span><br><span class="line">		System.out.println(&quot;b2的值为：&quot;+b2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>b1的值为：-2<br>b2的值为：2</p>
</blockquote>
<p><strong>字母大小写转换</strong><br>toLowerCase()  //转换成小写字符<br>toUpperCase()  //转换成大写字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;abcDEF&quot;;</span><br><span class="line">		String s1&#x3D;s.toLowerCase();</span><br><span class="line">		String s2&#x3D;s.toUpperCase();</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">		System.out.println(s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>abcdef<br>ABCDEF</p>
</blockquote>
<p><strong>将字符串转换为字符数组</strong><br>toCharArray()</p>
<blockquote>
<p>char a[]=s.toCharArray();</p>
</blockquote>
<p><strong>字符串数字转数字</strong></p>
<blockquote>
<p>String s=”1234”;<br>int a=Integer.valueOf(s);</p>
</blockquote>
<p><strong>数字转字符串</strong></p>
<blockquote>
<p>int a=1234;<br>String s=a+””;<br>//或者<br>String s=String.valueOf(a);</p>
</blockquote>
<p><strong>字符串分割</strong><br>split()   //使字符串按指定的分割字符或字符串对内容进行分割，并将分割后的结果存放在字符数组中<br>如果想定义多个分割符，可以使用符号”|”，例如”,|=”表示分割符为”,”和”=”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s&#x3D;&quot;192.168.0.1&quot;;</span><br><span class="line">		&#x2F;&#x2F;按照&quot;.&quot;进行分割</span><br><span class="line">		String[] temp1&#x3D;s.split(&quot;\\.&quot;);</span><br><span class="line">		for(String a:temp1)</span><br><span class="line">		System.out.print(&quot;[&quot;+a+&quot;]&quot;);</span><br><span class="line">		</span><br><span class="line">		System.out.println();	&#x2F;&#x2F;换行</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;按照&quot;.&quot;进行两次分割</span><br><span class="line">		String[] temp2&#x3D;s.split(&quot;\\.&quot;,2);</span><br><span class="line">		for(String a:temp2)</span><br><span class="line">		System.out.print(&quot;[&quot;+a+&quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>[192][168][0][1]<br>[192][168.0.1]</p>
</blockquote>
<p><strong>格式化字符串</strong><br>format()  //格式化之后的新字符串使用本地默认语言环境</p>
<p><strong>日期和时间字符串格式化</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Date date&#x3D;new Date();</span><br><span class="line">	String year&#x3D;String.format(&quot;%tY&quot;, date);</span><br><span class="line">	String mouth&#x3D;String.format(&quot;%tB&quot;, date);</span><br><span class="line">	String day&#x3D;String.format(&quot;%td&quot;, date);</span><br><span class="line">	System.out.println(year+&quot;&#x2F;&quot;+mouth+&quot;&#x2F;&quot;+day+&quot;&#x2F;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>2020/一月/16/</p>
</blockquote>
<p><strong><a href="https://blog.csdn.net/DZ881115/article/details/79579000" target="_blank" rel="noopener">Java 中各种常规类型格式化</a></strong><br><strong><a href="https://blog.csdn.net/qq_42182367/article/details/81909999" target="_blank" rel="noopener">字符串生成器</a></strong></p>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p><strong>创建一维数组</strong><br>1、先声明，再用new运算符进行内存分配</p>
<blockquote>
<p>int a[]      //数组元素类型 数组名字[];<br>int[] a      //数组元素类型[] 数组名字;</p>
</blockquote>
<p>分配内存空间</p>
<blockquote>
<p>a=new int[5];    //数组名字=new 数组元素类型[数组元素个数];</p>
</blockquote>
<p>2、声明的同时为数组分配内存</p>
<blockquote>
<p>int a[]=new int[5];    //数组元素类型 数组名=new 数组元素类型[数组元素个数]</p>
</blockquote>
<p>初始化一维数组</p>
<blockquote>
<p>int a1[]=new int[]{1,2,3,4,5};<br>int a2[]={1,2,3,4,5};</p>
</blockquote>
<p><strong>二维数组</strong><br>可分别为每一维分配内存</p>
<blockquote>
<p>int a[][]<br>a=new a[2][];<br>a[0]=new int[2];<br>a[1]=new int[3];</p>
</blockquote>
<p><strong>使用二维数组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	int a[][]&#x3D;new int[3][4];</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">		for(j&#x3D;0;j&lt;a[i].length;j++) &#123;</span><br><span class="line">			System.out.print(a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>0000<br>0000<br>0000</p>
</blockquote>
<p><strong>遍历数组</strong><br>利用foreach语句使遍历数组时更简单<br>foreach的书写格式</p>
<blockquote>
<p>for(元素类型 元素名称:遍历数组(集合)(或能进行迭代的)){<br>    语句<br>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	int a[][]&#x3D;&#123;&#123;4,3&#125;,&#123;1,2&#125;&#125;;</span><br><span class="line">	int i&#x3D;0;		&#x2F;&#x2F;外层循环计数器变量</span><br><span class="line">	for(int x[]:a) &#123;	&#x2F;&#x2F;外层循环变量为一维数组</span><br><span class="line">		i++;</span><br><span class="line">		int j&#x3D;0;</span><br><span class="line">		for(int e:x) &#123;	&#x2F;&#x2F;循环遍历每一个数组元素</span><br><span class="line">			j++;</span><br><span class="line">			if(i&#x3D;&#x3D;a.length&amp;&amp;j&#x3D;&#x3D;x.length) &#x2F;&#x2F;判断变量是二维数组中的最后一个元素</span><br><span class="line">			System.out.print(e);</span><br><span class="line">			else System.out.print(e+&quot;、&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>4、3、1、2</p>
</blockquote>
<p><strong>填充替换数组元素</strong><br>通过Arrays类的静态方法fill()来对数组中的元素进行替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	int a[]&#x3D;new int[5];</span><br><span class="line">	Arrays.fill(a, 1);	&#x2F;&#x2F;替换数组中的所有元素</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">		System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">	int b[]&#x3D;new int[5];</span><br><span class="line">	Arrays.fill(b,2,4,1);	&#x2F;&#x2F;替换数组中[2,4)元素</span><br><span class="line">	for(int j&#x3D;0;j&lt;b.length;j++) &#123;</span><br><span class="line">		System.out.print(b[j]+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>1 1 1 1 1<br>0 0 1 1 0 </p>
</blockquote>
<p><strong>对数组进行排序</strong><br>Arrays类的静态sort()方法可以对任意类型的数组进行升序排序<br>String类型数组的数字排在字母前面，大写字母排在小写字母前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	int a[]&#x3D; &#123;1,3,5,7,9,2,4,6,8,10&#125;;</span><br><span class="line">	Arrays.sort(a);</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">		System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>1 2 3 4 5 6 7 8 9 10 </p>
</blockquote>
<p><strong>复制数组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	int a[]&#x3D; &#123;1,3,5,7,9,2,4,6,8,10&#125;;</span><br><span class="line">	int a1[]&#x3D;Arrays.copyOf(a, 5);	&#x2F;&#x2F;复制至满足新数组的长度5</span><br><span class="line">	for(int i&#x3D;0;i&lt;a1.length;i++) &#123;</span><br><span class="line">		System.out.print(a1[i]+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">	int a2[]&#x3D;Arrays.copyOfRange(a, 2, 6);	&#x2F;&#x2F;复制a数组[2,6)位置的元素到新数组</span><br><span class="line">	for(int j&#x3D;0;j&lt;a2.length;j++) &#123;</span><br><span class="line">		System.out.print(a2[j]+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>1 3 5 7 9<br>5 7 9 2 </p>
</blockquote>
<p><strong>数组查询</strong><br>binarySearch() //该方法返回要搜索元素的索引值，调用前应先对数组排序sort()<br>可以在特定索引范围内搜索，若元素未在范围内找到，则返回”-1”或”-“(插入点)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	int a[]&#x3D; &#123;1,3,5,7,9,2,4,6,8,10&#125;;</span><br><span class="line">	Arrays.sort(a);</span><br><span class="line">	int index&#x3D;Arrays.binarySearch(a, 4);</span><br><span class="line">		System.out.print(&quot;4的索引位置是：&quot;+index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>4的索引位置是：3</p>
</blockquote>
<p><strong>数组排序算法</strong><br>1、冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BubbleSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a[]&#x3D; &#123;1,3,5,7,9,2,4,6,8,10&#125;;</span><br><span class="line">		BubbleSort sorter&#x3D;new BubbleSort();</span><br><span class="line">		sorter.sort(a);</span><br><span class="line">	&#125;</span><br><span class="line">	public void sort(int a[]) &#123;</span><br><span class="line">		for(int i&#x3D;1;i&lt;a.length;i++) &#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;a.length-i;j++) &#123;</span><br><span class="line">				if(a[j]&gt;a[j+1]) &#123;</span><br><span class="line">					int temp&#x3D;a[j];</span><br><span class="line">					a[j]&#x3D;a[j+1];</span><br><span class="line">					a[j+1]&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		showA(a);</span><br><span class="line">	&#125;</span><br><span class="line">	public void showA(int a[]) &#123;</span><br><span class="line">		for(int i:a) &#123;</span><br><span class="line">			System.out.print(&quot; &quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、直接选择排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	int a[]&#x3D; &#123;1,3,5,7,9,2,4,6,8,10&#125;;</span><br><span class="line">&#x2F;&#x2F;	int min,k,x&#x3D;0;</span><br><span class="line">&#x2F;&#x2F;	for(int i&#x3D;1;i&lt;a.length;i++) &#123;</span><br><span class="line">&#x2F;&#x2F;			min&#x3D;a[i];k&#x3D;i;</span><br><span class="line">&#x2F;&#x2F;		for(int j&#x3D;i;j&lt;a.length;j++) &#123;</span><br><span class="line">&#x2F;&#x2F;			x++;</span><br><span class="line">&#x2F;&#x2F;			if(a[j]&lt;min) &#123;</span><br><span class="line">&#x2F;&#x2F;				min&#x3D;a[j];</span><br><span class="line">&#x2F;&#x2F;				k&#x3D;j;</span><br><span class="line">&#x2F;&#x2F;			&#125;</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">&#x2F;&#x2F;		int temp&#x3D;a[i];</span><br><span class="line">&#x2F;&#x2F;		a[i]&#x3D;a[k];</span><br><span class="line">&#x2F;&#x2F;		a[k]&#x3D;temp;</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	int x&#x3D;0;</span><br><span class="line">&#x2F;&#x2F;	int index;</span><br><span class="line">&#x2F;&#x2F;	for(int i&#x3D;1;i&lt;a.length;i++) &#123;</span><br><span class="line">&#x2F;&#x2F;		index &#x3D;0;</span><br><span class="line">&#x2F;&#x2F;		for(int j&#x3D;1;j&lt;&#x3D;a.length-i;j++) &#123;</span><br><span class="line">&#x2F;&#x2F;			x++;</span><br><span class="line">&#x2F;&#x2F;			if(a[j]&gt;a[index]) &#123;</span><br><span class="line">&#x2F;&#x2F;				index&#x3D;j;</span><br><span class="line">&#x2F;&#x2F;			&#125;</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">&#x2F;&#x2F;		int temp&#x3D;a[a.length-i];</span><br><span class="line">&#x2F;&#x2F;		a[a.length-i]&#x3D;a[index];</span><br><span class="line">&#x2F;&#x2F;		a[index]&#x3D;temp;</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">	int x&#x3D;0;</span><br><span class="line">	for(int i&#x3D;1;i&lt;a.length;i++) &#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;a.length-i;j++) &#123;</span><br><span class="line">			x++;</span><br><span class="line">			if(a[j]&gt;a[j+1]) &#123;</span><br><span class="line">				int temp&#x3D;a[j];</span><br><span class="line">				a[j]&#x3D;a[j+1];</span><br><span class="line">				a[j+1]&#x3D;temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">	System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">	System.out.print(&quot;\n&quot;+x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组转列表</strong></p>
<blockquote>
<p>Arrays.asList(nums)</p>
</blockquote>
<hr>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a><strong>类与对象</strong></h2><p><em>定义成员方法</em></p>
<blockquote>
<p>权限修饰符 返回值类型 方法名(参数类型 参数名){<br>  ···//方法体<br>  return 返回值;<br>}<br>this关键字代表本类对象的引用,this.name(成员变量)=name(形参)<br>this可以调用有参数的构造方法，this(参数);</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Book &#123;	&#x2F;&#x2F;新建类</span><br><span class="line">	private String name;	&#x2F;&#x2F;定义一个String型变量</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		int id&#x3D;0;		&#x2F;&#x2F;局部变量</span><br><span class="line">		setName(&quot;Java&quot;);	&#x2F;&#x2F;调用类中其他方法</span><br><span class="line">		return id+this.name;</span><br><span class="line">	&#125;</span><br><span class="line">	private void setName(String name) &#123;</span><br><span class="line">		this.name&#x3D;name;	&#x2F;&#x2F;将参数值赋予类中成员变量</span><br><span class="line">	&#125;</span><br><span class="line">	public Book getBook() &#123;</span><br><span class="line">		return this;	&#x2F;&#x2F;返回Book类引用</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>类的构造方法</em><br>构造方法是与类同名的方法，对象的创建就是通过构造方法完成的。<br>每当类实例化一个对象，类都会自动调用构造方法。构造方法没有返回值。</p>
<blockquote>
<p>public book(){ //book是构造方法的名称<br>     …//构造方法体<br>}</p>
</blockquote>
<p>构造方法存在的意义时，通过构造方法的调用，可以创建对象<br>构造方法的调用：new 构造方法名(实参列表)</p>
<p><em>静态变量、常量、方法</em><br>由satic修饰的变量、常量、方法被称作静态成员，调用时使用语法</p>
<blockquote>
<p>类名.静态类成员</p>
</blockquote>
<p>无static修饰时调用语法:</p>
<blockquote>
<p>引用.方法</p>
</blockquote>
<p><em>注：</em><br>在静态方法中不可以使用this关键字/不可以直接调用非静态方法<br>Java中规定不能将方法体内的局部变量声明为static</p>
<p>如果在执行类时，希望先执行类的初始化动作，可以使用static定义一个静态区域，例如</p>
<blockquote>
<p>public class example{<br>        static{<br>            //some<br>        }<br>}</p>
</blockquote>
<p><strong>对象</strong><br>Java中通过new操作符来创建对象，创建之后可以使用”对象.类成员”来获取对象的属性和行为<br>对象的引用：</p>
<blockquote>
<p>类名 对象引用名称<br>Book book=new Book();</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	int i&#x3D;47;</span><br><span class="line">	public void call() &#123;</span><br><span class="line">		System.out.println(&quot;调用call()方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public Main() &#123;	&#x2F;&#x2F;定义构造方法</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Main t1&#x3D;new Main();	&#x2F;&#x2F;创建一个对象</span><br><span class="line">		Main t2&#x3D;new Main(); &#x2F;&#x2F;创建另一个对象</span><br><span class="line">		t2.i&#x3D;60;</span><br><span class="line">		System.out.println(&quot;第一个实例对象调用变量i的结果：&quot;+t1.i);</span><br><span class="line">		t1.call();</span><br><span class="line">		System.out.println(&quot;第二个实例对象调用变量i的结果：&quot;+t2.i);</span><br><span class="line">		t2.call();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>第一个实例对象调用变量i的结果：47<br>调用call()方法<br>第二个实例对象调用变量i的结果：60<br>调用call()方法</p>
</blockquote>
<p><em>对象的比较</em><br>1、”==”运算符<br>比较两个对象引用的地址是否相等<br>2、equals()方法<br>比较两个对象引用的内容是否相等</p>
<hr>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a><strong>包装类</strong></h2><p><em>Integer类</em><br>1、构造方法</p>
<blockquote>
<p>Integer number=new Integer();  //括号中可以是int或string型 </p>
</blockquote>
<p>2、常用方法<br>compareTo(Integer anotherInteger)  //比较大小<br>parseInt(String str) //返回包含在由str指定的字符串中的数字的等价整数值<br>toString() //将Integer对象转换为十进制字符串<br>toBinaryString() //二进制<br>toHexString() //十六进制<br>toOctalString()  //八进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String str[]&#x3D; &#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;&#125;;</span><br><span class="line">		int sum&#x3D;0;</span><br><span class="line">		for(int i&#x3D;0;i&lt;str.length;i++) &#123;</span><br><span class="line">			int myint&#x3D;Integer.parseInt(str[i]);</span><br><span class="line">			sum+&#x3D;myint;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sum); &#x2F;&#x2F;输出sum的值为15</span><br><span class="line">		String s&#x3D;Integer.toBinaryString(sum); &#x2F;&#x2F;获取数字的二进制表示</span><br><span class="line">		System.out.print(s); &#x2F;&#x2F;输出该二进制表示为1111</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、常量<br>MAX_VALUE：  最大值 2^31-1<br>MIN_VALUE：  最小值 -2^31<br>SIZE：  用来以二进制补码形式表示int的位数<br>TYPE：  表示基本类型int的Class实例</p>
<p><em>Boolean类</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Boolean b1&#x3D;new Boolean(true);</span><br><span class="line">		Boolean b2&#x3D;new Boolean(&quot;true&quot;);&#x2F;&#x2F;可忽略大小写</span><br><span class="line">		Boolean b3&#x3D;new Boolean(&quot;ok&quot;);</span><br><span class="line">		System.out.println(&quot;b1:&quot;+b1.booleanValue());</span><br><span class="line">		System.out.println(&quot;b2:&quot;+b2.booleanValue());</span><br><span class="line">		System.out.println(&quot;b3:&quot;+b3.booleanValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>b1:true<br>b2:true<br>b3:false</p>
</blockquote>
<p><em>Byte类</em><br>构造方法<br>1、以byte型变量作为参数，创建Byte对象</p>
<blockquote>
<p>byte mybyte=45;<br>Byte b=new Byte(mybyte);</p>
</blockquote>
<p>2、以String型变量作为参数，创建Byte对象</p>
<blockquote>
<p>Byte mybyte=new Byte(“12”);</p>
</blockquote>
<p><em>Character类</em><br>一个Character类型对象包含类型为char的单个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Character mychar1&#x3D;new Character(&#39;A&#39;);</span><br><span class="line">		Character mychar2&#x3D;new Character(&#39;a&#39;);</span><br><span class="line">		System.out.println(mychar1+&quot;是大写字母吗？&quot;</span><br><span class="line">				+Character.isUpperCase(mychar1));</span><br><span class="line">		System.out.println(mychar2+&quot;是小写字母吗？&quot;</span><br><span class="line">				+Character.isLowerCase(mychar2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>A是大写字母吗？true<br>a是小写字母吗？true</p>
</blockquote>
<p><em>Double类</em><br>构造方法<br>1、Double(double value)<br>2、Double(String str) //用字符串表示的double类型的浮点值</p>
<p><em>Number类</em></p>
<hr>
<h2 id="数字处理类"><a href="#数字处理类" class="headerlink" title="数字处理类"></a><strong>数字处理类</strong></h2><p><strong>数字格式化</strong><br>DecimalFormat是NumberFormat的一个子类，用于格式化十进制数字，按照模板格式化数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;使用实例化对象时设置格式化模式</span><br><span class="line">		DecimalFormat myFormat1&#x3D;new DecimalFormat(&quot;0000,000.000&quot;);</span><br><span class="line">		System.out.println(myFormat1.format(123456.789));</span><br><span class="line">		&#x2F;&#x2F;使用applyPattern()方法对数字进行格式化</span><br><span class="line">		DecimalFormat myFormat2&#x3D;new DecimalFormat();</span><br><span class="line">		myFormat2.applyPattern(&quot;0.00&quot;);  &#x2F;&#x2F;保留小数点后两位</span><br><span class="line">		System.out.println(myFormat2.format(123456.789));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>0,123,456.789<br>123456.79</p>
</blockquote>
<p>其他方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DecimalFormat myFormat&#x3D;new DecimalFormat();</span><br><span class="line">		myFormat.setGroupingSize(2); &#x2F;&#x2F;设置将数字分组为2</span><br><span class="line">		System.out.println(myFormat.format(123456.789));</span><br><span class="line">		myFormat.setGroupingUsed(false); &#x2F;&#x2F;设置不允许数字进行分组</span><br><span class="line">		System.out.println(myFormat.format(123456.789));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>12,34,56.789<br>123456.789</p>
</blockquote>
<p><strong>Math类</strong></p>
<p><em>三角函数方法</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;90度的正弦：&quot;+Math.sin(Math.PI&#x2F;2));</span><br><span class="line">		System.out.println(&quot;120度的弧度值：&quot;+Math.toRadians(120.0));</span><br><span class="line">		System.out.println(&quot;Π&#x2F;2的角度值：&quot;+Math.toDegrees(Math.PI&#x2F;2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>指数函数方法</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;e的平方值：&quot;+Math.exp(2));</span><br><span class="line">		System.out.println(&quot;以e为底2的对数值：&quot;+Math.log(2));</span><br><span class="line">		System.out.println(&quot;以10为底2的对数值：&quot;+Math.log10(2));</span><br><span class="line">		System.out.println(&quot;4的平方根：&quot;+Math.sqrt(4));  &#x2F;&#x2F;2.0</span><br><span class="line">		System.out.println(&quot;8的立方根：&quot;+Math.cbrt(8));  &#x2F;&#x2F;2.0</span><br><span class="line">		System.out.println(&quot;2的3次方根：&quot;+Math.pow(2,3)); &#x2F;&#x2F;8.0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>取整函数方法</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;ceil()返回大于等于参数的整数：&quot;+Math.ceil(5.2)); &#x2F;&#x2F;6.0</span><br><span class="line">		System.out.println(&quot;floor()返回小于等于参数的整数：&quot;+Math.floor(2.5)); &#x2F;&#x2F;2.0</span><br><span class="line">		System.out.println(&quot;rint()返回参数最接近的整数：&quot;+Math.rint(2.7));  &#x2F;&#x2F;3.0</span><br><span class="line">		System.out.println(&quot;round()参数加上0.5后返回与参数最近的整数：&quot;+Math.round(3.4)); &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>取最大值、最小值：</em>  Math.max/min(a,b);<br><em>取绝对值：</em>  Math.abs(a);</p>
<p><strong>随机数</strong><br>1、Math类中存在一个random()方法，用于产生随机数字，默认生成大于等于0.0并且小于1.0的随机数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a&#x3D;(int)1+(int)(Math.random()*(100-1)); &#x2F;&#x2F;产生1-100之间的随机数</span><br><span class="line">		char s&#x3D;(char)(&#39;a&#39;+Math.random()*(&#39;z&#39;-&#39;a&#39;+1));&#x2F;&#x2F;产生a-z之间的随机字母</span><br><span class="line">		System.out.println(a+&quot;\n&quot;+s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Random类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Random r&#x3D;new Random(); &#x2F;&#x2F;实例化一个Random类</span><br><span class="line">		System.out.println(&quot;随机整数[0,10):&quot;+r.nextInt(10));</span><br><span class="line">		System.out.println(&quot;随机产生一个概率密度为高斯分布的双精度值:&quot;</span><br><span class="line">		+r.nextGaussian());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>大数字运算</strong><br>1、BigInteger类：针对大整数的处理类  //参数以字符串形式代表要处理的数字<br>2、BigDecimal类：针对大小数的处理类  //参数可以是字符串形式或者数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		BigInteger a&#x3D;new BigInteger(&quot;4&quot;);</span><br><span class="line">		System.out.println(&quot;加法操作:&quot;+a.add(new BigInteger(&quot;2&quot;)));</span><br><span class="line">		System.out.println(&quot;取商:&quot;+a.divideAndRemainder(new BigInteger(&quot;3&quot;))[0]);</span><br><span class="line">		System.out.println(&quot;取余数:&quot;+a.divideAndRemainder(new BigInteger(&quot;3&quot;))[1]);</span><br><span class="line">		System.out.println(&quot;二次方:&quot;+a.pow(2));</span><br><span class="line">		System.out.println(&quot;取相反数:&quot;+a.negate());</span><br><span class="line">		</span><br><span class="line">		BigDecimal b&#x3D;new BigDecimal(4.0);</span><br><span class="line">		System.out.println(b.add(new BigDecimal(&quot;2.0&quot;)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="接口、继承与多态"><a href="#接口、继承与多态" class="headerlink" title="接口、继承与多态"></a><strong>接口、继承与多态</strong></h2><p><strong>继承</strong><br>1、继承是面向对象的三大特征之一，三大特征分别是：封装，继承，多态<br>2、继承基本的作用是：代码复用。有了继承才有了以后的”方法的覆盖”和”多态机制”<br>3、继承语法格式：</p>
<blockquote>
<p>[修饰符列表] class 类名 extends 父类名{<br>         类体=属性+方法<br>}<br>4、Java语言当中的继承只支持单继承，但是一个类可以间接继承其他类<br>5、私有的不支持继承，构造方法不支持继承，其他数据可以被继承<br>6、java语言中假设一个类没有显示继承任何类，该类默认继承JavaSE库中的java.lang.Object类<br>7、子类可以覆盖父类的属性和方法</p>
</blockquote>
<p>创建父类Computer，子类pad</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Computer &#123;&#x2F;&#x2F;父类：电脑</span><br><span class="line">	String screen&#x3D;&quot;液晶显示屏&quot;;</span><br><span class="line">	void startup() &#123;</span><br><span class="line">		System.out.println(&quot;正在开机&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class pad extends Computer&#123;&#x2F;&#x2F;子类：平板电脑</span><br><span class="line">	String battery&#x3D;&quot;5000毫安电池&quot;;</span><br><span class="line">	void open3G() &#123;</span><br><span class="line">		System.out.println(&quot;打开3G网络&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;子类独有属性，在父类中不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line">	String screen&#x3D;&quot;液晶显示屏&quot;;</span><br><span class="line">	void startup() &#123;</span><br><span class="line">		System.out.println(&quot;正在开机&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class pad extends Computer&#123;</span><br><span class="line">	String battery&#x3D;&quot;5000毫安电池&quot;;</span><br><span class="line">	void open3G() &#123;</span><br><span class="line">		System.out.println(&quot;打开3G网络&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Computer com&#x3D;new Computer(); &#x2F;&#x2F;创建一个父类的对象</span><br><span class="line">		pad ipad&#x3D;new pad();  &#x2F;&#x2F;创建一个子类的对象</span><br><span class="line">		System.out.print(com.screen);  &#x2F;&#x2F;输出父类的属性</span><br><span class="line">		com.startup(); &#x2F;&#x2F;调用父类的方法</span><br><span class="line">		System.out.print(ipad.screen); &#x2F;&#x2F;子类有从父类继承的属性和方法</span><br><span class="line">		ipad.startup();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>方法的重写</em><br>可将父类的方法复制到子类中，更改方法内容<br>子类与父类调用同一个方法，但完成的方式不同</p>
<p>super关键字：可以直接调用父类对象</p>
<blockquote>
<p>super.属性<br>super(); //调用父类的构造方法<br>super.成员方法();</p>
</blockquote>
<p><em>object类</em> :所有类的父类<br>getClass():返回对象执行时的Class实例，使用此实例调用getName()方法可以取得类的名称</p>
<blockquote>
<p>getClass().getname();<br>toString():将对象返回为字符串形式<br>equals():比较两个对象的实际内容</p>
</blockquote>
<p><strong>对象的封装</strong><br>封装的好处：<br>1、封装之后，对外提供简单的操作程序<br>2、封装之后会形成真正的”对象”,真正的”独立体”<br>3、封装就意味着以后的程序可以重复使用。并且这个事物应该适应性比较强，在任何场合都可以使用<br>4、封装之后，对于事物本身，提高了安全性。</p>
<p>封装的步骤：<br>1、所有属性私有化，使用private关键字进行修饰，修饰的所有数据只能在本类中访问。<br>2、对外提供简单的操作入口，提供两个公开方法，set方法–修改，get方法–读取。没有static修饰符修饰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	private int age;&#x2F;&#x2F;属性私有化</span><br><span class="line">	&#x2F;&#x2F;set方法没有返回值，因为set方法只负责修改数据</span><br><span class="line">	public void setAge(int a) &#123;</span><br><span class="line">		&#x2F;&#x2F;填写业务逻辑代码进行安全检测</span><br><span class="line">		if(a&lt;0||a&gt;150) &#123;</span><br><span class="line">			System.out.println(&quot;对不起，您提供的年龄不合法&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;如果程序可以执行到这里，说明年龄合法，则进行赋值运算</span><br><span class="line">		age&#x3D;a;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		User user&#x3D;new User();</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		user.setAge(-100);</span><br><span class="line">		&#x2F;&#x2F;读取</span><br><span class="line">		System.out.println(user.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>对象类型的转换</strong><br>向上转型:将子类的对象赋值个父类,成为父类的一个实例化对象，自动类型转换<br>向下转型:将父类对象赋予子类对象，并强制转换为子类类型</p>
<p><strong>方法的重载</strong><br>方法重载又称overload，当功能相似的时候，尽可能让方法名相同<br>构成方法重载的条件：1、在同一个类中 2、方法名相同 3、参数列表不同(数量、顺序，类型)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	 &#x2F;&#x2F;参数的类型不同，对应调用的方法不同</span><br><span class="line">	 &#x2F;&#x2F;此时区分方法不再依靠方法名，依靠的是参数类型</span><br><span class="line">	 System.out.println(sum(1,2));</span><br><span class="line">	 System.out.println(sum(1L,2L));</span><br><span class="line">	 System.out.println(sum(1.0,2.0));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public static int sum(int a,int b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static long sum(long a,long b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static double sum(double a,double b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多态</strong><br>多态语法机制：<br>1、Animal、Cat、Bird三个类之间的关系:Cat、Bird继承Animal,Cat、Bird之间没有任何继承关系<br>2、多态中涉及向上转型和向下转型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		System.out.println(&quot;动物在移动&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">	&#x2F;&#x2F;重写从父类中继承过来的方法</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		System.out.println(&quot;猫在走猫步&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;子类对象特有的方法</span><br><span class="line">	public void Mouse() &#123;</span><br><span class="line">		System.out.println(&quot;猫抓老鼠&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Bird extends Animal&#123;</span><br><span class="line">	&#x2F;&#x2F;重写从父类中继承的方法</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		System.out.println(&quot;鸟儿在飞翔&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;使用多态语法机制</span><br><span class="line">		Animal a&#x3D;new Cat();</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * 1、java程序永远都分为编译阶段和运行阶段</span><br><span class="line">		 * 2、编译阶段编译器检查a这个引用的数据类型为Animal,编译通过</span><br><span class="line">		 * 这个过程称为静态绑定，编辑阶段绑定</span><br><span class="line">		 * 3、在程序运行阶段，java堆内存中真实创建的对象是Cat对象，</span><br><span class="line">		 * 因而以下程序在运行阶段调用Cat对象的move()方法</span><br><span class="line">		 * 此时发生了程序的动态绑定，运行阶段绑定</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		a.move();&#x2F;&#x2F;猫在走猫步</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象编程的核心：定义好类，然后将类实例化对象，给一个环境驱使一下，让各个对象之间协作起来形成一个系统<br>多态在实际中的应用：以主人喂养宠物为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;降低程序的耦合度，提高程序的扩展力</span><br><span class="line">public class Master &#123;</span><br><span class="line">	</span><br><span class="line">	public void feed(Pet pet) &#123;</span><br><span class="line">		pet.eat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Pet &#123;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Dog extends Pet&#123;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;小狗正在啃骨头&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Cat extends Pet&#123;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;小猫正在吃鱼&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建主人对象</span><br><span class="line">		Master Roy&#x3D;new Master();</span><br><span class="line">		&#x2F;&#x2F;创建小猫对象</span><br><span class="line">		Cat tom&#x3D;new Cat();</span><br><span class="line">		&#x2F;&#x2F;创建小狗对象</span><br><span class="line">		Dog dudu&#x3D;new Dog();</span><br><span class="line">		&#x2F;&#x2F;主人喂养猫&#x2F;狗</span><br><span class="line">		Roy.feed(tom);</span><br><span class="line">		Roy.feed(dudu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>抽象类</strong><br>1、定义抽象类：class关键字前加abstract<br>2、抽象类无法被实例化<br>3、虽然抽象类没有办法实例化，但是抽象类也有构造方法，该构造方法是给子类创建对象用的。<br>4、抽象类中可以定义抽象方法：在方法的修饰符中加 abstract关键字，并且抽象方法应该以”;”结束<br>例如： public abstract void m1();<br>5、抽象类中不一定有抽象方法，但抽象方法一定在抽象类中<br>6、一个非抽象的类继承抽象类，必须将抽象类中的抽象方法进行覆盖、实现、重写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class A &#123;</span><br><span class="line">	&#x2F;&#x2F;创建方法</span><br><span class="line">	A()&#123;</span><br><span class="line">		System.out.println(&quot;A...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;抽象方法</span><br><span class="line">	public abstract void m1();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;入口</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;抽象类无法创建对象，例如：A a&#x3D;new A();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;多态</span><br><span class="line">		A a&#x3D;new B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	public void m1() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;&#x2F;&#x2F;对抽象方法进行覆盖、实现、重写</span><br><span class="line">	B()&#123;</span><br><span class="line">		super(); &#x2F;&#x2F;调用父类的构造方法，但并没有创建父类对象</span><br><span class="line">		System.out.println(&quot;B...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>接口</strong><br><em>接口的基础语法</em><br>1、接口也是一种引用类型，可以等同看作类，定义接口语法：修饰符 interface 接口名{}<br>2、接口中只能出现：常量、抽象方法<br>3、接口其实是一个特殊的抽象类，特殊在接口是完全抽象的<br>4、接口中没有构造方法，无法被实例化。<br>5、接口和接口之间可以多继承<br>6、一个类可以实现多个接口(这里的“实现”可以等同看作“继承”)<br>7、一个非抽象的类实现接口，需要将接口中所有的方法“实现/重写/覆盖”<br>8、可以在测试类中使用多态机制调用方法,如:</p>
<blockquote>
<p>D d=new F();<br>        d.m2();</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface A&#123;</span><br><span class="line">	&#x2F;&#x2F;常量：必须用public static final修饰</span><br><span class="line">	public static final double PI&#x3D;3.14;</span><br><span class="line">	&#x2F;&#x2F;public static final可以省略</span><br><span class="line">	byte MAX_VALUE&#x3D;127; &#x2F;&#x2F;常量</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;抽象方法：接口中所有抽象方法都是public abstract</span><br><span class="line">	public abstract void m1();</span><br><span class="line">	&#x2F;&#x2F;public abstract可以省略</span><br><span class="line">	void m2();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">	void m1();</span><br><span class="line">&#125;</span><br><span class="line">interface C&#123;</span><br><span class="line">	void m2();</span><br><span class="line">&#125;</span><br><span class="line">interface D extends B,C&#123;</span><br><span class="line">	void m3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;implements是实现的意思，是一个关键字</span><br><span class="line">&#x2F;&#x2F;implements和 extends意义相同</span><br><span class="line">class MyClass implements B,C&#123;</span><br><span class="line">	public void m1() &#123;&#125;</span><br><span class="line">	public void m2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class F implements D&#123;</span><br><span class="line">	public void m1() &#123;&#125;</span><br><span class="line">	public void m2() &#123;&#125;</span><br><span class="line">	public void m3() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>接口作用</em><br>1、可以使项目分层，所有层都面向接口开发，开发效率提高<br>2、接口使代码和代码之间的耦合度降低，可以随意切换</p>
<hr>
<h2 id="类的高级特性"><a href="#类的高级特性" class="headerlink" title="类的高级特性"></a><strong>类的高级特性</strong></h2><p><strong>软件包机制</strong><br>1、为了解决类的命名冲突问题，在类名前加命名空间(包机制)<br>2、在java中使用package语句定义包(单包、复包)<br>3、package语句只能出现在.java源文件的第一行<br>4、package定义的格式，通常采用 公司域名倒叙.项目名.模块名;<br>5、完整的类名是带有包名的<br>6、使用import关键字可以导入包：import com.lzm //导入包中所有类 ，import com.lzm.Math //导入包中Math类<br>使用import导入静态成员：import static 静态成员</p>
<p><strong>final关键字</strong><br>1、final是一个关键字，表示最终的，不可变的<br>2、final修饰的类无法被继承<br>3、final修饰的方法无法被覆盖<br>4、final修饰的变量一旦赋值之后，不可重新赋值<br>5、final修饰的实例变量，java语言规定使用final修饰之后，必须手动赋值，不能采用系统默认值<br>final修饰的实例变量是不可变的，这种变量一般和static联合使用，被称为“常量”</p>
<blockquote>
<p>常量 public static final 类型 常量名=值;<br>6、final修饰的引用指向某个对象之后不能指向其他对象，但是所指向对象的内存是可以被修改的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class A&#123;</span><br><span class="line">	public static final double PI&#x3D;3.1415926;</span><br><span class="line">	</span><br><span class="line">	final int a&#x3D;100;</span><br><span class="line">	</span><br><span class="line">	final int b;</span><br><span class="line">	public A()&#123;</span><br><span class="line">		this.b&#x3D;200;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;在构造方法执行过程中给实例变量赋值</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final int c&#x3D;100;</span><br><span class="line">		final int d;</span><br><span class="line">		d&#x3D;100;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部类</strong><br>内部类重要的作用，可以访问外部类中私有的数据<br><em>静态内部类</em><br>1、静态内部类可以等同看作静态变量<br>2、静态内部类可以直接访问外部类的静态数据，无法直接访问成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">	&#x2F;&#x2F;静态方法</span><br><span class="line">	private static void m1() &#123;&#125;</span><br><span class="line">		</span><br><span class="line">	&#x2F;&#x2F;成员方法</span><br><span class="line">	private void m2() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;静态内部类</span><br><span class="line">	static class InnerClass&#123;</span><br><span class="line">		&#x2F;&#x2F;静态方法</span><br><span class="line">		public static void m3() &#123;</span><br><span class="line">			m1();</span><br><span class="line">			&#x2F;&#x2F;m2();不能调用成员方法</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;成员方法</span><br><span class="line">		public void m4() &#123;</span><br><span class="line">			m1();</span><br><span class="line">			&#x2F;&#x2F;m2();不能调用成员方法</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;执行m3</span><br><span class="line">		OuterClass.InnerClass.m3();&#x2F;&#x2F;也可省略外部类</span><br><span class="line">		&#x2F;&#x2F;执行m4</span><br><span class="line">		InnerClass inner&#x3D; new OuterClass.InnerClass();</span><br><span class="line">		inner.m4();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>成员内部类</em><br>1、成员内部类可以等同看作成员变量<br>2、成员内部类中不能有静态声明<br>3、成员内部类可以访问外部类所有的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">	&#x2F;&#x2F;静态方法</span><br><span class="line">	private static void m1() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	&#x2F;&#x2F;成员方法</span><br><span class="line">	private void m2() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;成员内部类</span><br><span class="line">	class InnerClass&#123;		</span><br><span class="line">		&#x2F;&#x2F;成员方法</span><br><span class="line">		public void m4() &#123;</span><br><span class="line">			m1();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建外部类对象</span><br><span class="line">		OuterClass out &#x3D;new OuterClass();</span><br><span class="line">		InnerClass in &#x3D;out.new InnerClass();</span><br><span class="line">		in.m4();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>局部内部类</em><br>1、局部内部类等同于局部变量<br>2、局部内部类不能用访问控制权限修饰符修饰<br>3、局部内部类在访问局部变量时，局部变量必须使用final修饰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">	&#x2F;&#x2F;成员方法</span><br><span class="line">	public void m1() &#123;</span><br><span class="line">		final int i&#x3D;10;</span><br><span class="line">		&#x2F;&#x2F;局部内部类</span><br><span class="line">		class InnerClass&#123;</span><br><span class="line">			&#x2F;&#x2F;内部类不能有静态方法</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;成员方法</span><br><span class="line">			public void m2() &#123;</span><br><span class="line">				System.out.print(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		&#x2F;&#x2F;调用m2();</span><br><span class="line">		InnerClass in&#x3D;new InnerClass();</span><br><span class="line">		in.m2();</span><br><span class="line">&#125;</span><br><span class="line">	&#x2F;&#x2F;入口</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		OuterClass out &#x3D; new OuterClass();</span><br><span class="line">		out.m1();&#x2F;&#x2F;在m1方法中调用m2</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>匿名内部类</em><br>优点：可以少写一个类<br>缺点：不能重复利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">	public static void t(C cs) &#123;</span><br><span class="line">		cs.logout();</span><br><span class="line">&#125;	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;调用t方法</span><br><span class="line">		&#x2F;&#x2F;t(new C1());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;使用匿名内部类的方式执行t方法</span><br><span class="line">		&#x2F;&#x2F;整个&quot;new C() &#123;&#125;&quot;就是匿名内部类</span><br><span class="line">		t(new C() &#123;</span><br><span class="line">			public void logout() &#123;</span><br><span class="line">				System.out.print(&quot;退出系统&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;接口</span><br><span class="line">interface C&#123;</span><br><span class="line">	void logout();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;编写一个类实现C接口</span><br><span class="line">&#x2F;*</span><br><span class="line">class C1 implements C&#123;</span><br><span class="line">	public void logout() &#123;</span><br><span class="line">		System.out.print(&quot;退出系统&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><p><strong>异常的基本概念</strong><br>1、异常模拟的是现实世界的”不正常的“事件<br>2、java中采用”类“去模拟异常</p>
<p>异常:在Java语言中，将程序执行中发生的不正常情况称为“异常”。<br>Java中的异常用于处理非预期的情况，如文件没找到，网络错误,非法的参数<br>Java程序运行过程中所发生的异常事件可分为两类:<br>1、Error: JVM系统内部错误、资源耗尽等严重情况<br>2、Exception:其它因编程错误或偶然的外在因素导致的一般性问题<br>一般所说的异常是指 Exception及其子类<br>例如:<br>●空指针访问<br>●试图读取不存在的文件<br>●网络连接中断</p>
<p>Exception类<br>构造方法<br>●public Exception();<br>●public Exception(String message) ; .<br>●Exception(String message, Throwable cause) ;<br>方法<br>●getMessage()<br>●getCause()<br>●printStackTrace()</p>
<p>处理异常有两种方式：<br>1、声明抛出 throws<br>2、捕捉 try…catch..</p>
<blockquote>
</blockquote>
<p>try{<br>    语句组<br>}catch(异常类名 异常形式参数名){<br>    异常处理语句组；<br>}<br>…<br>finally{<br>    异常处理语句组；<br>}</p>
<p>其中，catch语句可以0至多个，可以没有finally语句<br>finally是捕获异常的体系中最终一定会执行的部分<br>在捕获异常的代码块中，如果前面的代码有异常，就不会执行后面的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i&#x3D;0;</span><br><span class="line">		</span><br><span class="line">		try &#123;&#x2F;&#x2F;用try&#123;&#125;来括住一段可能出现异常的代码</span><br><span class="line">			System.out.print(3&#x2F;i);</span><br><span class="line">			&#x2F;&#x2F;由于异常，使中断，可以通过异常处理机制防止程序的中断</span><br><span class="line">		&#125;catch(Exception e) &#123;&#x2F;&#x2F;当不知道捕获的异常的类型，使用所有异常的父类</span><br><span class="line">			e.printStackTrace();&#x2F;&#x2F;得到捕获异常的类型</span><br><span class="line">			e.getMessage();&#x2F;&#x2F;得到异常信息</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(&quot;ok&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>抛出异常</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		A a&#x3D;new A();</span><br><span class="line">		try &#123;</span><br><span class="line">		a.test();</span><br><span class="line">		&#125;catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">	int i;</span><br><span class="line">	public void test() throws Exception&#123; </span><br><span class="line">		&#x2F;&#x2F;可以使用throws在代码这抛出异常，在调用方法去捕获处理</span><br><span class="line">		A a&#x3D;null;</span><br><span class="line">		System.out.println(a.i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at hello.A.test(Main.java:18)</span><br><span class="line">at hello.Main.main(Main.java:8)</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p>重写方法不能抛出比被重写方法范围更大的异常类型</p>
<p><em>自定义异常</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyException extends Exception&#123;&#x2F;&#x2F;创建自定义异常，继承Exception类</span><br><span class="line">	public MyException(String ErrorMessage) &#123;&#x2F;&#x2F;构造方法</span><br><span class="line">		super(ErrorMessage);&#x2F;&#x2F;父类构造方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义方法，抛出异常</span><br><span class="line">static void test() throws Exception&#123;</span><br><span class="line">		int age&#x3D;-1;</span><br><span class="line">		if(age&gt;0&amp;&amp;age&lt;&#x3D;120) &#123;</span><br><span class="line">			System.out.println(&quot;年龄是&quot;+age);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			throw new Exception(&quot;年龄不在0到129&#x3D;0之间&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>##<strong>列表</strong><br><strong>ArrayList类</strong><br>ArrayList类代表长度可变的数组，允许对元素进行随机的快速访问</p>
<blockquote>
<p>List&lt;类型&gt; list = new ArrayList&lt;类型&gt;();</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;列表定义及判断其中是否包含某个值</span><br><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">boolean a &#x3D; list.contains(0);</span><br><span class="line">System.out.println(a); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a><strong>集合类</strong></h2><p><a href="https://blog.csdn.net/qq_40877598/article/details/78473877" target="_blank" rel="noopener">集合子类</a></p>
<p>Collection 是接口不能被实例化 ，都是子类完成<br>   Collection c = new ArrayList();<br>boolean add()    添加，返回值是布尔类型<br>boolean  remove(object o)    删除指定元素,返回值是布尔类型<br>clear()        : 清空集合<br>Boolean contains(object o)   :   判断是否包含某个元素<br>isEmpty（）  ：  判断是否为空<br>int  size()      :  集合长度，元素个数　　<br>Iterator iterator(); 获取集合所依赖的迭代器对象，通过迭代器的方法完成集合的迭代（遍历）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建集合</span><br><span class="line">		Collection c&#x3D;new ArrayList(); &#x2F;&#x2F;多态，父类型引用指向子类对象</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;添加元素</span><br><span class="line">		c.add(&quot;123&quot;);</span><br><span class="line">		c.add(3.14);</span><br><span class="line">		c.add(false);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;迭代，遍历</span><br><span class="line">		&#x2F;&#x2F;1、获取迭代器对象</span><br><span class="line">		Iterator it&#x3D;c.iterator();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2、开始调用方法，完成遍历，迭代</span><br><span class="line">		&#x2F;&#x2F;while循环</span><br><span class="line">		while(it.hasNext()) &#123; &#x2F;&#x2F;判断是否有下一个元素返回Boolean值</span><br><span class="line">			Object element&#x3D;it.next();&#x2F;&#x2F;将迭代器向下移动一位并且取出指向元素</span><br><span class="line">			System.out.println(element);&#x2F;&#x2F;123 3.14 false</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;for循环</span><br><span class="line">		&#x2F;*</span><br><span class="line">		for(Iterator it&#x3D;c.iterator();it.hasNext();) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">		*&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<br>Java集合主要有3种重要的类型:<br>●List:是一个有序集合，可以放重复的数据。<br>ArrayList集合的底层是数组，数组是有下标的，适合查询操作<br>LinkedList集合的底层是链表，适合增删操作</p>
<p>add(a,b) 在下标为a的位置添加值b<br>get(a) 得到下标为a位置的数据</p>
<p>●Set:是一个无序集合，不允许放重复的数据。<br>●Map: 是一个无序集合，集合中包含一个键对象，一个值对象，键对象不允许重复</p>
<p><strong>Set集合</strong><br>Hashset是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。我们大多数时候说的set集合指的都是HashSet<br>HashSet按Hash算法来存储集合中的元索,因此具有很好的存取和查找性能。<br>HashSet具有以下特点:<br>1、不能保证元素的排列顺序<br>2、不可重复<br>3、HashSet不是线程安全的<br>4、集合元素可以使null<br>当向HashSet集合中存入一个元素时，HashSet 会调用该对象的hashCode()方法来得到该对象的hashCode值,<br>然后根据hashCode值决定该对象在HashSet中的存储位置。<br>如果两个元素的equals()方法返回true,但它们的hashCode()返回值不相等,<br>hashSet将会把它们存储在不同的位置，但依然可以添加成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建Set集合</span><br><span class="line">		Set&lt;Object&gt; s&#x3D;new HashSet&lt;Object&gt;();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;无序不可重复</span><br><span class="line">		s.add(1);</span><br><span class="line">		s.add(1);</span><br><span class="line">		s.add(100);</span><br><span class="line">		s.add(85);</span><br><span class="line">		s.add(80);</span><br><span class="line">		s.add(&#39;a&#39;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		Iterator&lt;Object&gt; it&#x3D;s.iterator();</span><br><span class="line">		while(it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">			&#x2F;&#x2F;80 1 a 100 85</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet底层数据结构是链表和哈希表（FIFO插入有序，唯一）<br>1、由链表保证元素有序<br>2、由哈希表保证元素唯一</p>
<p>TreeSet<br>底层数据结构是红黑树,自平衡的排序二叉树。(唯一，有序)</p>
<ol>
<li>如何保证元素排序的呢?<br>自然排序<br>比较器排序</li>
<li>如何保证元素唯一性的呢?<br>根据比较的返回值是否是0来决定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		HashSet&lt;String&gt; hashSet&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">		LinkedHashSet&lt;String&gt; linkedHashSet&#x3D;new LinkedHashSet&lt;&gt;();</span><br><span class="line">		TreeSet&lt;String&gt; treeSet&#x3D;new TreeSet&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		for(String data:Arrays.asList(&quot;B&quot;,&quot;E&quot;,&quot;D&quot;,&quot;C&quot;,&quot;A&quot;)) &#123;</span><br><span class="line">			hashSet.add(data);</span><br><span class="line">			linkedHashSet.add(data);</span><br><span class="line">			treeSet.add(data);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;不保证有序 [A, B, C, D, E]</span><br><span class="line">		System.out.println(&quot;HashSet:&quot;+hashSet);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;FIFO保证安装插入顺序排序 [B, E, D, C, A]</span><br><span class="line">		System.out.println(&quot;LinkedHashSet:&quot;+linkedHashSet);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;内部实现排序 [A, B, C, D, E]</span><br><span class="line">		System.out.println(&quot;treeSet:&quot;+treeSet);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet集合实现 Comparable接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class UpdateStu implements Comparable&lt;Object&gt; &#123;&#x2F;&#x2F; 创建类实现Comparable接口</span><br><span class="line">	String name;</span><br><span class="line">	long id;</span><br><span class="line">	</span><br><span class="line">	public UpdateStu(String name, long id) &#123; &#x2F;&#x2F;构造方法</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;重写</span><br><span class="line">	public int compareTo(Object o) &#123;</span><br><span class="line">		UpdateStu upstu&#x3D;(UpdateStu) o;</span><br><span class="line">		int ret&#x3D;id&gt;upstu.id?1:(id&#x3D;&#x3D;upstu.id?0:-1);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;封装</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public long getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setId(long id) &#123;</span><br><span class="line">		this.id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建UpdateStu对象</span><br><span class="line">		UpdateStu stu1&#x3D;new UpdateStu(&quot;赵&quot;, 01011);</span><br><span class="line">		UpdateStu stu2&#x3D;new UpdateStu(&quot;钱&quot;, 01021);</span><br><span class="line">		UpdateStu stu3&#x3D;new UpdateStu(&quot;孙&quot;, 01051);</span><br><span class="line">		UpdateStu stu4&#x3D;new UpdateStu(&quot;李&quot;, 01012);</span><br><span class="line">		</span><br><span class="line">		TreeSet&lt;UpdateStu&gt; tree&#x3D;new TreeSet&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;向集合中添加对象</span><br><span class="line">		tree.add(stu1);</span><br><span class="line">		tree.add(stu2);</span><br><span class="line">		tree.add(stu3);</span><br><span class="line">		tree.add(stu4);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		Iterator&lt;UpdateStu&gt; it&#x3D;tree.iterator();</span><br><span class="line">		while(it.hasNext()) &#123;</span><br><span class="line">			UpdateStu stu&#x3D;(UpdateStu) it.next();</span><br><span class="line">			System.out.println(stu.getId()+&quot; &quot;+stu.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;截取排在stu2和stu3之间的对象</span><br><span class="line">		it&#x3D;tree.subSet(stu2, stu3).iterator(); </span><br><span class="line">		System.out.print(&quot;截取中间部分的集合:&quot;);</span><br><span class="line">		while(it.hasNext()) &#123;</span><br><span class="line">			UpdateStu stu&#x3D;(UpdateStu) it.next();</span><br><span class="line">			System.out.println(stu.getId()+&quot;&quot;+stu.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">	521 赵</span><br><span class="line">	522 李</span><br><span class="line">	529 钱</span><br><span class="line">	553 孙</span><br><span class="line">	截取中间部分的集合:529钱</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>Map集合</strong></p>
<p>Map集合没有继承 Collection接口，其提供的是key到value的映射，每个key只能映射一个value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Map&lt;String, String&gt; map&#x3D;new HashMap&lt;String, String&gt;();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建Emp对象</span><br><span class="line">		Emp emp1&#x3D;new Emp(&quot;351&quot;,&quot;张三&quot;);</span><br><span class="line">		Emp emp2&#x3D;new Emp(&quot;512&quot;,&quot;李四&quot;);</span><br><span class="line">		Emp emp3&#x3D;new Emp(&quot;853&quot;,&quot;王一&quot;);</span><br><span class="line">		Emp emp4&#x3D;new Emp(&quot;125&quot;,&quot;赵六&quot;);</span><br><span class="line">		Emp emp5&#x3D;new Emp(&quot;341&quot;,&quot;黄七&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;将对象添加到集合中</span><br><span class="line">		map.put(emp4.getE_id(), emp4.getE_name());</span><br><span class="line">		map.put(emp5.getE_id(), emp5.getE_name());</span><br><span class="line">		map.put(emp1.getE_id(), emp1.getE_name());</span><br><span class="line">		map.put(emp2.getE_id(), emp2.getE_name());</span><br><span class="line">		map.put(emp3.getE_id(), emp3.getE_name());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取Map集合中的key对象集合</span><br><span class="line">		Set&lt;String&gt; set&#x3D;map.keySet();</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; it&#x3D;set.iterator();</span><br><span class="line">		System.out.println(&quot;HashMap类实现的Map集合，无序：&quot;);</span><br><span class="line">		while(it.hasNext()) &#123;</span><br><span class="line">			String str&#x3D;(String)it.next();</span><br><span class="line">			String name&#x3D;(String)map.get(str);</span><br><span class="line">			System.out.println(str+&quot;&quot;+name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建TreeMap集合对象</span><br><span class="line">		TreeMap&lt;String, String&gt; treemap&#x3D;new TreeMap&lt;String, String&gt;();</span><br><span class="line">		treemap.putAll(map); &#x2F;&#x2F;向集合添加对象</span><br><span class="line">		Iterator&lt;String&gt; iter&#x3D;treemap.keySet().iterator();</span><br><span class="line">		System.out.println(&quot;TreeMap类实现的Map集合，键对象升序：&quot;);</span><br><span class="line">		while(iter.hasNext()) &#123;</span><br><span class="line">			String str&#x3D;(String)iter.next();</span><br><span class="line">			String name&#x3D;(String)treemap.get(str);</span><br><span class="line">			System.out.println(str+&quot;&quot;+name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Emp&#123;</span><br><span class="line">	private String e_id;</span><br><span class="line">	private String e_name;</span><br><span class="line">	</span><br><span class="line">	public Emp(String e_id, String e_name) &#123;</span><br><span class="line">		this.e_id &#x3D; e_id;</span><br><span class="line">		this.e_name &#x3D; e_name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String getE_id() &#123;</span><br><span class="line">		return e_id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setE_id(String e_id) &#123;</span><br><span class="line">		this.e_id &#x3D; e_id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getE_name() &#123;</span><br><span class="line">		return e_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setE_name(String e_name) &#123;</span><br><span class="line">		this.e_name &#x3D; e_name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> 	HashMap类实现的Map集合，无序：</span><br><span class="line">		341黄七</span><br><span class="line">		125赵六</span><br><span class="line">		512李四</span><br><span class="line">		853王一</span><br><span class="line">		351张三</span><br><span class="line">	TreeMap类实现的Map集合，键对象升序：</span><br><span class="line">		125赵六</span><br><span class="line">		341黄七</span><br><span class="line">		351张三</span><br><span class="line">		512李四</span><br><span class="line">		853王一</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="I-O-输入-输出"><a href="#I-O-输入-输出" class="headerlink" title="I/O(输入/输出)"></a><strong>I/O(输入/输出)</strong></h2><p><a href="https://blog.csdn.net/ryuenkyo/article/details/81198093" target="_blank" rel="noopener">I/O</a></p>
<p>流是一组有序的数据序列，可分为输入流和输出流两种<br>所有的输入流类都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类<br>所有的输出流类都是抽象类OutputStream（字节输出流）或抽象类Writer（字符输出流）的子类</p>
<p><strong>File类</strong><br>构造方法:File file=new File(“路径”);<br>file.createNewFile(); //创建该文件<br>String name=file.getName(); //获取文件名称<br>file.delete();  //将文件删除</p>
<p>FileOutputStream类：提供基本的文件写入能力<br>FileInputStream类:简单文件读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File file&#x3D;new File(&quot;w.txt&quot;); &#x2F;&#x2F;创建文件对象</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;创建FileOutputStream对象</span><br><span class="line">			FileOutputStream out&#x3D;new FileOutputStream(file);</span><br><span class="line">			&#x2F;&#x2F;创建byte型数组</span><br><span class="line">			byte buy[]&#x3D;&quot;人来人去人一场，都不过只是平常&quot;.getBytes();</span><br><span class="line">			out.write(buy); &#x2F;&#x2F;将数组中的信息写入文件</span><br><span class="line">			out.close();</span><br><span class="line">		&#125;catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			FileInputStream in&#x3D;new FileInputStream(file);</span><br><span class="line">			byte byt[]&#x3D;new byte[1024];</span><br><span class="line">			int len&#x3D;in.read(byt);&#x2F;&#x2F;从文件中读取信息</span><br><span class="line">			&#x2F;&#x2F;将文件中的信息输出</span><br><span class="line">			System.out.println(new String(byt,0,len));</span><br><span class="line">			in.close();</span><br><span class="line">		&#125;catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace(); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileWriter 类从 OutputStreamWriter 类继承而来。该类按字符向流中写入数据。<br>FileReader类从InputStreamReader类继承而来。该类按字符读取流中数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"> </span><br><span class="line">public class FileRead &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException &#123;</span><br><span class="line">        File file &#x3D; new File(&quot;Hello1.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建文件</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        &#x2F;&#x2F; creates a FileWriter Object</span><br><span class="line">        FileWriter writer &#x3D; new FileWriter(file);</span><br><span class="line">        &#x2F;&#x2F; 向文件写入内容</span><br><span class="line">        writer.write(&quot;This\n is\n an\n example\n&quot;);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">        &#x2F;&#x2F; 创建 FileReader 对象</span><br><span class="line">        FileReader fr &#x3D; new FileReader(file);</span><br><span class="line">        char[] a &#x3D; new char[50];</span><br><span class="line">        fr.read(a); &#x2F;&#x2F; 从数组中读取内容</span><br><span class="line">        for (char c : a)</span><br><span class="line">            System.out.print(c); &#x2F;&#x2F; 一个个打印字符</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h2><p><a href="https://zhuanlan.zhihu.com/p/80519709" target="_blank" rel="noopener">详解</a><br>反射:将类的各个组成部分封装为其他对象，这就是反射机制<br>反射机制中主要掌握的类型，都是SUN提供的反射机制中的类，可以创建对象<br>java.lang.Class; //代表类的实体，在运行的java应用程序中表示类和接口<br>java.lang.reflect.Constructer; //代表类的构造方法<br>java.lang.reflect.Field; //代表类的成员变量（属性）<br>java.lang.reflect.Method; //代表类的方法<br>java.lang.reflect.Modifier; //修饰符信息</p>
<p>反射机制的作用：<br>1、反编译：.class–&gt;.java<br>2、通过反射机制访问java类的属性，方法，构造方法等</p>
<p>获取Class类型对象的三种方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1、Class.forName(&quot;全类名&quot;)</span><br><span class="line">&#x2F;&#x2F;多用于配置文件，将类名定义在配置文件中。读取文件，加载类</span><br><span class="line">Class c1 &#x3D; Class.forName(&quot;hello.Person&quot;);&#x2F;&#x2F;复制包名+类名</span><br><span class="line">System.out.println(c1);&#x2F;&#x2F;class hello.Person</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、类名.class</span><br><span class="line">&#x2F;&#x2F;多用于参数传递</span><br><span class="line">Class c2 &#x3D; Person.class;</span><br><span class="line">System.out.println(c2);&#x2F;&#x2F;class hello.Person</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、对象.getClass()</span><br><span class="line">&#x2F;&#x2F;多用于对象的获取字节码的方式</span><br><span class="line">Person p &#x3D; new Person();</span><br><span class="line">Class c3 &#x3D; p.getClass();</span><br><span class="line">System.out.println(c3);&#x2F;&#x2F;class hello.Person</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同一个字节码文件在一次程序运行过程中，只会被加载一次</span><br><span class="line">&#x2F;&#x2F;不论通过哪一种方式获取的Class对象都是同一个</span><br></pre></td></tr></table></figure>

<p>获取类信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		&#x2F;&#x2F;获取Person的Class对象</span><br><span class="line">		Class personClass &#x3D; Person.class;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;**********************************&#x2F;&#x2F;</span><br><span class="line">		&#x2F;&#x2F;一、获取成员变量</span><br><span class="line">		&#x2F;&#x2F;1、获取所有public修饰的成员变量</span><br><span class="line">		Field[] fields &#x3D; personClass.getFields();</span><br><span class="line">		for(Field field : fields) &#123;</span><br><span class="line">			System.out.println(field);&#x2F;&#x2F;public java.lang.String hello.Person.a</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2、获取指定名称的public修饰的成员变量</span><br><span class="line">		Field a &#x3D; personClass.getField(&quot;a&quot;);</span><br><span class="line">		&#x2F;&#x2F;获取成员变量a的值</span><br><span class="line">		Person p &#x3D; new Person();</span><br><span class="line">		Object value1 &#x3D; a.get(p);</span><br><span class="line">		System.out.println(value1);&#x2F;&#x2F;null</span><br><span class="line">		&#x2F;&#x2F;设置a的值</span><br><span class="line">		a.set(p, &quot;张三&quot;);</span><br><span class="line">		System.out.println(p);&#x2F;&#x2F;Person [name&#x3D;null, age&#x3D;0, a&#x3D;张三]</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;3、获取所有的成员变量，不考虑修饰符</span><br><span class="line">		Field[] declaredFields &#x3D; personClass.getDeclaredFields();</span><br><span class="line">		for(Field declaredField : declaredFields) &#123;</span><br><span class="line">			System.out.println(declaredField);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;4、获取指定名称的成员变量</span><br><span class="line">		Field d &#x3D; personClass.getDeclaredField(&quot;d&quot;);</span><br><span class="line">		&#x2F;&#x2F;d是私有化成员，先进行忽略访问权限修饰符的安全检查</span><br><span class="line">		d.setAccessible(true);&#x2F;&#x2F;暴力反射</span><br><span class="line">		Object value2 &#x3D; d.get(p);</span><br><span class="line">		System.out.println(value2);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;**********************************&#x2F;&#x2F;</span><br><span class="line">		&#x2F;&#x2F;二、获取构造方法</span><br><span class="line">		&#x2F;&#x2F;1、带参数的构造方法</span><br><span class="line">		Constructor constructor &#x3D; personClass.getConstructor(String.class,int.class);</span><br><span class="line">		&#x2F;&#x2F;创建对象</span><br><span class="line">		Object person &#x3D; constructor.newInstance(&quot;张三&quot;,23);</span><br><span class="line">		System.out.println(person);</span><br><span class="line">		&#x2F;&#x2F;Person [name&#x3D;张三, age&#x3D;23, a&#x3D;null, b&#x3D;null, c&#x3D;null, d&#x3D;null]</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2、空参的构造方法</span><br><span class="line">		Object o &#x3D; personClass.newInstance();&#x2F;&#x2F;不推荐使用</span><br><span class="line">		System.out.println(o);</span><br><span class="line">		&#x2F;&#x2F;Person [name&#x3D;null, age&#x3D;0, a&#x3D;null, b&#x3D;null, c&#x3D;null, d&#x3D;null]</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;**********************************&#x2F;&#x2F;</span><br><span class="line">		&#x2F;&#x2F;三、获取成员方法</span><br><span class="line">		&#x2F;&#x2F;1、获取指定名称的方法</span><br><span class="line">		Method eat_method1 &#x3D; personClass.getMethod(&quot;eat&quot;);</span><br><span class="line">		&#x2F;&#x2F;执行方法</span><br><span class="line">		eat_method1.invoke(p);&#x2F;&#x2F;空参</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2、获取指定参数列表的方法</span><br><span class="line">		Method eat_method2 &#x3D; personClass.getMethod(&quot;eat&quot;,String.class);</span><br><span class="line">		&#x2F;&#x2F;执行方法</span><br><span class="line">		eat_method2.invoke(p,&quot;rice&quot;);&#x2F;&#x2F;有参</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;3、获取所有public修饰的方法&#x2F;&#x2F;包含Object中的一些方法</span><br><span class="line">		Method[] methods &#x3D; personClass.getMethods();</span><br><span class="line">		for(Method method : methods) &#123;</span><br><span class="line">			System.out.println(method);</span><br><span class="line">			&#x2F;&#x2F;method.setAccessible(true);&#x2F;&#x2F;获取私有方法</span><br><span class="line">			String name &#x3D; method.getName();&#x2F;&#x2F;获取方法名称</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取类名</span><br><span class="line">		String classname &#x3D; personClass.getName();</span><br><span class="line">		System.out.println(classname);&#x2F;&#x2F;hello.Person</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	public String a;&#x2F;&#x2F;新添加成员变量之后要重新生成toString方法</span><br><span class="line">	protected String b;</span><br><span class="line">	String c;</span><br><span class="line">	private String d;</span><br><span class="line">	</span><br><span class="line">	public Person() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Person(String name, int age) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Person [name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;, &quot;</span><br><span class="line">				+ &quot;a&#x3D;&quot; + a + &quot;, b&#x3D;&quot; + b + &quot;, c&#x3D;&quot; + c + &quot;, d&#x3D;&quot; + d + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;eat...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void eat(String food) &#123;</span><br><span class="line">		System.out.println(&quot;eat...&quot;+food);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Annotation注解<br>三个基本的Annotation如下：<br>1、@Override         限定重写父类的方法<br>2、@Deprecated     标示已过时<br>3、@SuppressWarnings     抑制编译器警告</p>
<hr>
<h2 id="枚举类型与泛型"><a href="#枚举类型与泛型" class="headerlink" title="枚举类型与泛型"></a><strong>枚举类型与泛型</strong></h2><p><strong>枚举</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;获取一个Season的对象</span><br><span class="line">		&#x2F;&#x2F;单例模式，每次执行Season.SPRING获得的是相同的对象</span><br><span class="line">		Season spring &#x3D; Season.SPRING;&#x2F;&#x2F;返回一个春季对象</span><br><span class="line">		spring.show();&#x2F;&#x2F;春天,春暖花开</span><br><span class="line">		spring.test();&#x2F;&#x2F;实现接口的枚举类</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Season implements Itest&#123;</span><br><span class="line">	&#x2F;&#x2F;相当于调用有参的私有构造方法private Season(String name, String desc)</span><br><span class="line">	SPRING(&quot;春天&quot;,&quot;春暖花开&quot;),</span><br><span class="line">	SUMMER(&quot;夏天&quot;,&quot;炎炎夏日&quot;),</span><br><span class="line">	AUTUMN(&quot;秋天，&quot;,&quot;秋高气爽&quot;),</span><br><span class="line">	WINTER(&quot;冬天&quot;,&quot;寒风凛冽&quot;);</span><br><span class="line">	</span><br><span class="line">	private final String name;</span><br><span class="line">	private final String desc;</span><br><span class="line">	</span><br><span class="line">	private Season(String name, String desc) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.desc &#x3D; desc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void show() &#123;</span><br><span class="line">		System.out.println(this.name+&quot;,&quot;+this.desc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		System.out.println(&quot;实现Itest接口的方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接口</span><br><span class="line">interface Itest&#123;</span><br><span class="line">	void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型</strong></p>
<p><em>泛型类</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		A&lt;String&gt; a1 &#x3D; new A&lt;String&gt;();&#x2F;&#x2F;在new A的对象指定泛型的类型String</span><br><span class="line">		a1.serKey(&quot;xxx&quot;); &#x2F;&#x2F;对象使用serKey(T key)方法中的key形参就是String</span><br><span class="line"> 		String s &#x3D; a1.getKey();&#x2F;&#x2F;返回值为String</span><br><span class="line"> 		</span><br><span class="line"> 		A a2 &#x3D; new A();&#x2F;&#x2F;不指定泛型，相当于指定了一个Object类型</span><br><span class="line"> 		</span><br><span class="line"> 		&#x2F;&#x2F;同样的类，但是在new对象时泛型指定不同的数据类型，这些对象不能相互赋值</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此处的泛型T可以任意的取名</span><br><span class="line">class A&lt;T&gt; &#123;</span><br><span class="line">	private T key;</span><br><span class="line">	</span><br><span class="line">	public void serKey(T key) &#123;</span><br><span class="line">		this.key &#x3D; key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public T getKey() &#123;</span><br><span class="line">		return this.key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>泛型接口</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		B&lt;Object&gt; b1 &#x3D; new B&lt;Object&gt;();</span><br><span class="line">		B&lt;String&gt; b2 &#x3D; new B&lt;String&gt;();</span><br><span class="line">		C c &#x3D; new C();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&lt;T&gt; &#123;</span><br><span class="line">	T test(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;未传入泛型实参时，与泛型类的定义相同</span><br><span class="line">&#x2F;&#x2F;在声明类的时候，需要将泛型的声明也一起加到类中</span><br><span class="line">class B&lt;T&gt; implements A&lt;T&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public T test(T t) &#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果实现接口时指定接口的泛型的具体数据类型</span><br><span class="line">&#x2F;&#x2F;这个类实现接口所有方法的位置都要泛型替换实际的具体数据类型</span><br><span class="line">class C implements A&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String test(String t) &#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>泛型方法</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&lt;E&gt;&#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个泛型变量</span><br><span class="line">	private E e;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;无返回值的泛型方法</span><br><span class="line">	public &lt;T&gt; void test(T s) &#123;</span><br><span class="line">		&#x2F;&#x2F;在类上定义的泛型，可以在普通的方法中使用</span><br><span class="line">		</span><br><span class="line">		System.out.println(this.e);</span><br><span class="line">		T t &#x3D; s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;有返回值的泛型方法</span><br><span class="line">	public &lt;T&gt; T test1(T s) &#123;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;形参为可变参数的泛型方法</span><br><span class="line">	public &lt;T&gt; void test2(T...strs) &#123;</span><br><span class="line">		for(T s : strs) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static &lt;T&gt; void test3(T t) &#123;</span><br><span class="line">		&#x2F;&#x2F;在静态方法中，不能使用类定义泛型</span><br><span class="line">		&#x2F;&#x2F;如果要使用泛型，只能使用静态方法自己定义的泛型</span><br><span class="line">		&#x2F;&#x2F;System.out.println(this.e);</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Test&lt;Object&gt; t &#x3D; new Test&lt;Object&gt;();</span><br><span class="line">		&#x2F;&#x2F;泛型方法，在调用之前没有固定的数据类型</span><br><span class="line">		&#x2F;&#x2F;在调用时，传入的参数时什么类型，就会把泛型改成什么类型</span><br><span class="line">		t.test(&quot;xxx&quot;);</span><br><span class="line">		Integer t1 &#x3D; t.test1(2);</span><br><span class="line">		Boolean t2 &#x3D; t.test1(true);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>通配符</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Dd d &#x3D; new Dd();</span><br><span class="line">		List&lt;String&gt; l1 &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">		d.test(l1);</span><br><span class="line">		</span><br><span class="line">		List&lt;C&gt; lc &#x3D; new ArrayList&lt;C&gt;();</span><br><span class="line">		d.test1(lc);</span><br><span class="line">		</span><br><span class="line">		List&lt;D&gt; ld &#x3D; new ArrayList&lt;D&gt;();</span><br><span class="line">		d.test1(ld);</span><br><span class="line">		</span><br><span class="line">		List&lt;IAImp1&gt; la &#x3D; new ArrayList&lt;IAImp1&gt;();</span><br><span class="line">		d.test3(la);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dd&#123;</span><br><span class="line">	public void test(List&lt;?&gt; list) &#123;</span><br><span class="line">		&#x2F;&#x2F;test()方法需要一个list集合的参数，不确定参数类型</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void test1(List&lt;? extends C&gt; list) &#123;</span><br><span class="line">		&#x2F;&#x2F;list参数的元素数据类型是C及其子类</span><br><span class="line">		&#x2F;&#x2F;C,D</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void test2(List&lt;? super C&gt; list) &#123;</span><br><span class="line">		&#x2F;&#x2F;list参数的元素数据类型是C及其父类</span><br><span class="line">		&#x2F;&#x2F;A,B,C</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void test3(List&lt;? extends IA&gt; list) &#123;</span><br><span class="line">		&#x2F;&#x2F;list参数的元素数据类型是IA的实现类</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line"></span><br><span class="line">class C extends B&#123;&#125;</span><br><span class="line"></span><br><span class="line">class D extends C&#123;&#125;</span><br><span class="line"></span><br><span class="line">interface IA&#123;&#125; </span><br><span class="line"></span><br><span class="line">class IAImp1 implements IA&#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。<br>进程(process)是程序的一次执行过程， 或是正在运行的一个程序。<br>动态过程:有它自身的产生、存在和消亡的过程。<br>如:运行中的QQ，运行中的MP3播放器<br>程序是静态的，进程是动态的<br>线程(thread)，进程可进一步细化 为线程，是一个程序内部的一条执行路径。<br>若一个程序可同一时间执行多个线程，就是支持多线程的<br>电脑CPU，CPU的核数，几核的CPU就代表同一个瞬时时间能处理任务数</p>
<p>多线程，一个进程（一个程序运行时），可以分化并执行多个线程（多个子程序）<br>何时需要多线程：<br>1、程序需要同时执行两个或多个任务。<br>2、程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。<br>3、需要一些后台运行的程序时。</p>
<p><strong>多线程的创建和启动</strong></p>
<p>Thread类的特性<br>1、每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体<br>想要在开启的多线程中运行的代码逻辑，就写到run方法里.<br>2、通过该Thread对象的start()方法来调用这个线程，用来启动线程，本质上就是运行run()方法</p>
<p>创建线程的两种方式<br>1.继承Thread类<br>1)定义子类继承Thread类。<br>2)子类中重写Thread类中的run方法。<br>3)创建Thread子类对象，即创建了线程对象。.<br>4)调用线程对象start方法: 启动线程，调用run方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread t0 &#x3D; new TestThread();</span><br><span class="line">		t0.start();&#x2F;&#x2F;启动线程，开始运行run方法中的代码</span><br><span class="line">		System.out.println(&quot;------&quot;);</span><br><span class="line">		System.out.println(&quot;------&quot;);</span><br><span class="line">		System.out.println(&quot;------&quot;);</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * 多次运行这个main()方法之后</span><br><span class="line">		 * 我们发现main方法中打印的3行与开启线程运行run方法中的打印语句是混合起来</span><br><span class="line">		 * 而且main方法中的打印与run方法中打印语句顺序是不固定的</span><br><span class="line">		 * main执行to.start()方法开启多线程之后，就相当于在main方法之外开启一个支流</span><br><span class="line">		 * to.start ()的之后的main方法的其他代码与run方法的代码并行运行</span><br><span class="line">		 * 这就是多线程的异步，这个异步是相对于执行to.start()的主程序来说的</span><br><span class="line">		 *&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;继承Thread类的方式实现多线程</span><br><span class="line">class TestThread extends Thread&#123;</span><br><span class="line">     &#x2F;&#x2F;重写run方法</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;Thread多线程运行的代码&quot;);</span><br><span class="line">		for(int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">			System.out.println(&quot;这是Thread多线程的逻辑代码：&quot;+ i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.实现Runnable接口（一般使用实现接口的方式来实现多线程）<br>1)定义子类，实现Runnable接口。<br>2)子类中重写Runnable接口中的run方法。<br>3)通过Thread类含参构造器创建线程对象。<br>4)将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。<br>5)调用Thread类的start方法:开启线程，调用Runnable子类接口的run方法。</p>
<p>[实现方法的好处]<br>1)避免了单继承的局限性<br>2)多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		Thread t1 &#x3D; new Thread(new Runnabletest());</span><br><span class="line">&#x2F;&#x2F;		t1.start();</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		Thread t2 &#x3D; new Thread(new Runnabletest(), &quot;t-1&quot;);&#x2F;&#x2F;传入线程名称</span><br><span class="line">&#x2F;&#x2F;		t2.start();</span><br><span class="line">		</span><br><span class="line">		Runnable run &#x3D; new Runnabletest();</span><br><span class="line">		Thread t3 &#x3D; new Thread(run, &quot;t-1&quot;);&#x2F;&#x2F;传入线程名称</span><br><span class="line">		t3.start();</span><br><span class="line">		Thread t4 &#x3D; new Thread(run, &quot;t-2&quot;);&#x2F;&#x2F;传入线程名称</span><br><span class="line">		t4.start();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;------&quot;);</span><br><span class="line">		System.out.println(&quot;------&quot;);</span><br><span class="line">		System.out.println(&quot;------&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用Runnable接口方式实现多线程</span><br><span class="line">class Runnabletest implements Runnable&#123;</span><br><span class="line">	int count &#x3D; 0;&#x2F;&#x2F;t3,t4调用时可以共享count资源</span><br><span class="line">	&#x2F;&#x2F;实现run方法</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;Runnable多线程运行的代码&quot;);</span><br><span class="line">		&#x2F;&#x2F;得到线程名称，可以区分是哪个线程运行的代码</span><br><span class="line">		for(int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;这是Runnable多线程的逻辑代码：&quot;+ count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多线程程序的优点:<br>1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。<br>2.提高计算机系统CPU的利用率<br>3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p>
<p>Thread类的有关方法<br>void start():启动线程，并执行对象的run()方法<br>run():线程在被调度时执行的操作<br>String getName():返回线程的名称I<br>void setName(String name):设置该线程名称<br>static currentThread():返回当前线程</p>
<p>线程的优先级控制<br>MAX_ PRIORITY (10) ;<br>MIN_ PRIORITY (1) ;<br>NORM_ PRIORITY (5) ;<br>u涉及的方法:<br>getPriority() :返回线程优先值<br>setPriority(int newPriority) :改变线程的优先级<br>线程创建时继承父线程的优先级<br>优先级是用数组1-10表示，数字越大优先级越高，如果没有设置默认优先级是5</p>
<p>static void yield():线程让步<br>Thread.yield();//线程让步<br>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程<br>若队列中没有同优先级的线程，忽略此方法</p>
<p>join():当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，<br>直到join()方法加入的join线程执行完为止,低优先级的线程也可以获得执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;------1&quot;);</span><br><span class="line">System.out.println(&quot;------2&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">	t3.join();&#x2F;&#x2F;相当于在这块把t3的run方法插入到这个位置执行</span><br><span class="line">	&#x2F;&#x2F;阻塞main方法中的System.out.println(&quot;------3&quot;);代码，先执行join进来的线程的代码</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">	&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;------3&quot;);</span><br></pre></td></tr></table></figure>
<p>static void sleep(long millis): (指定时间:毫秒)<br>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执.行,时间到后重排队。<br>抛出InterruptedException异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		Thread.sleep(1000);&#x2F;&#x2F;当前线程睡眠1000毫秒，每隔一秒执行一次循环,打印变慢</span><br><span class="line">	&#125; catch (InterruptedException e) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	count++;</span><br><span class="line">	System.out.println(Thread.currentThread().getName()+&quot;这是Runnable多线程的逻辑代码：&quot;+ count);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>stop():强制线程生命期结束<br>boolean isAlive():返回boolean,判断线程是否还活着</p>
<p><strong>线程的生命周期</strong><br>JDK中用Thread.State枚举表示了线程的几种状态<br>要想实现多线程，必须在主线程中创建新的线程对象。Java语 言使用Thread类及其子类的对象<br>来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态:<br>1、新建:当一 个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态<br>2、就绪:处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件<br>3、运行:当就绪的线程被调度并获得处理器资源时,便进入运行状态，run()方法定义了线程的操作和功能<br>4、阻塞:在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态<br>5、死亡:线程完成了它的全部工作或线程被提前强制性地中止</p>
<p><strong>线程的同步</strong><br>多线程出现安全问题的原因:<br>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，<br>还没有执行完，另一个线程参与进来执行。导致共享数据的错误。<br>解决办法:<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行</p>
<p>1、同步代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Object obj &#x3D; new Object();&#x2F;&#x2F;锁对象</span><br><span class="line">synchronized (obj) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、同步方法<br>可以直接在方法上加上synchronized关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void run() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、同步锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock(true);&#x2F;&#x2F;公平锁，多个线程公平拥有执行权	</span><br><span class="line">lock.lock();</span><br><span class="line">	try&#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized是java 内置关键字，在jvm层面，Lock 是个java类;<br>synchronized无法判断是否获取锁的状态，Lock 可以判断是否获取到锁;<br>synchronized会自动释放锁(a线程执行完同步代码会释放锁; b线程执行过程中发生异常会释放锁)，<br>Lock 需在fnally中手工释放锁( unlock)方法释放锁)，否则容易造成线程死锁;<br>用synchronized关键字的两个线程1和线程2,如果当前线程1获得锁，线程2线程等待。<br>如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了;<br>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平(两者皆可)<br>Lock锁适合大量同步的代码的同步问题，synchronized 锁适合代码少量的同步问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;1、创建电影票对象</span><br><span class="line">		Ticket ticket &#x3D; new Ticket();</span><br><span class="line">		&#x2F;&#x2F;2、创建Thread对象，执行电影票售卖</span><br><span class="line">		Thread t1 &#x3D; new Thread(ticket,&quot;窗口1&quot;);</span><br><span class="line">		Thread t2 &#x3D; new Thread(ticket,&quot;窗口2&quot;);</span><br><span class="line">		Thread t3 &#x3D; new Thread(ticket,&quot;窗口3&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ticket implements Runnable&#123;</span><br><span class="line">	private int ticketNum &#x3D; 10;&#x2F;&#x2F;电影票数据量，默认10张</span><br><span class="line">	</span><br><span class="line">	Lock lock &#x3D; new ReentrantLock(true);&#x2F;&#x2F;公平锁，多个线程公平拥有执行权	</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			try&#123;</span><br><span class="line">				if(ticketNum&gt;0) &#123;&#x2F;&#x2F;判断是否有票</span><br><span class="line">					&#x2F;&#x2F;有票，让线程睡眠100毫秒，模拟售票</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(100);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					&#x2F;&#x2F;打印当前售出的票数字和线程名,票数减一</span><br><span class="line">					String name &#x3D; Thread.currentThread().getName();</span><br><span class="line">					System.out.println(name+&quot;销售电影票：&quot;+ticketNum--);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;finally &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a><strong>网络通信</strong></h2><p>TCP/ip模式是一种层次结构，共分为4层，分别应用层，传输层、互联网层和网络层。<br>各层实现特定的功能，提供特定的服务和访问接口，并且具有相对的独立性。</p>
<p>TCP与IP协议<br>TCP:可靠,传输大小无限制,但是需要时间来建立连接，差错控制开发大，主要用于文本、程序等可靠性高的数据传输。<br>UDP:不可靠,传输大小限制在64K以下,不需要建立连接，差错控制开销小，主要用于类似图像、声音、网络游戏、视<br>频会议等等对可靠性要求没有那么高的业务进行传输。</p>
<p>一般而言，一台计算机只有单一的练到网络的物理连接，所有的数据都通过次链接对内，对外送达特定的计算机，这就是端口。<br>公认端口0-1023<br>比如80端口分配给<a href="http://www.21端口分配给FTP" target="_blank" rel="noopener">www.21端口分配给FTP</a><br>注册端口1024- 49151分 配给用户进程或应用程序<br>动态/私有端口49152–65535</p>
<p>查看所有端口:netstat -ano<br>查看指定端口:netstat -aonIfindstr “808”<br>查看指定进程:tasklistlfindstr “808”<br>查看具体程序:使用任务管理器查看PID</p>
<p>网络程序中的套接字（Socket）用于将应用程序与端口链接起来。</p>
<p>Tcp程序设计基础<br>Tcp网络程序设计是指利用Socket类编写通信程序，利用TCP协议进行通信的两个应用程序是有主次之分的，<br>一个称为服务器程序，另一个称为客户机程序，两者的功能和编写方法大不一样，服务器端与客户端的交互过程。</p>
<p>InetAddress类<br>java.net包中的InetAddress类是IP地址相关的类，利用该类可以获取IP地址、主机地址等信息。<br>常用的方法如表<br>getByName(String host) 返回值 InetAddress 获取Host相对应的InetAddress对象<br>getHostAddress（） 返回值String 获取InetAddress对象所含的IP地址<br>getHostName（） 返回值String 获取此IP地址的主机名<br>getLocalHost（） InetAddress 返回本地主机的InetAddress对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) throws UnknownHostException &#123;</span><br><span class="line">		InetAddress ip;</span><br><span class="line">		ip &#x3D; InetAddress.getLocalHost(); &#x2F;&#x2F;实例化对象</span><br><span class="line">		System.out.println(&quot;本机名：&quot;+ip.getHostName()); &#x2F;&#x2F;获取本机名</span><br><span class="line">		System.out.println(&quot;ip地址：&quot;+ip.getHostAddress());&#x2F;&#x2F;获取本机ip地址</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a><strong>数据库操作</strong></h2>]]></content>
  </entry>
  <entry>
    <title>newpapername</title>
    <url>/2019/12/15/newpapername/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
